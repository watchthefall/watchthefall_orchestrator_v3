<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WatchTheFall Portal</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#00ff00">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="WTF Portal">
    
    <!-- App Icons -->
    <link rel="manifest" href="/portal/static/manifest.json">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect fill='%23000' width='100' height='100'/%3E%3Ctext y='70' font-size='70' fill='%2300ff00' font-family='Arial,sans-serif' font-weight='bold'%3E‚ö°%3C/text%3E%3C/svg%3E">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'%3E%3Crect fill='%23000' width='180' height='180' rx='40'/%3E%3Ctext x='90' y='130' font-size='100' fill='%2300ff00' font-family='Arial,sans-serif' font-weight='bold' text-anchor='middle'%3E‚ö°%3C/text%3E%3C/svg%3E">
    <!-- FFmpeg.WASM Library -->
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            min-height: 100vh;
        }
        
        body.offline-mode {
            border-top: 4px solid #ff6600;
        }
        
        #offlineBanner {
            background: #ff6600;
            color: #000;
            padding: 12px 20px;
            text-align: center;
            font-weight: 600;
            display: none;
        }
        
        body.offline-mode #offlineBanner {
            display: block;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: #111;
            padding: 20px;
            border-bottom: 2px solid #00ff00;
            margin-bottom: 30px;
        }
        
        h1 {
            color: #00ff00;
            font-size: 24px;
            font-weight: 700;
        }
        
        .subtitle {
            color: #888;
            font-size: 14px;
            margin-top: 5px;
        }
        
        .section {
            background: #1a1a1a;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #333;
        }
        
        .section h2 {
            color: #00ff00;
            font-size: 18px;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }
        
        .upload-zone {
            border: 2px dashed #444;
            padding: 40px;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .upload-zone:hover {
            border-color: #00ff00;
            background: #1f1f1f;
        }
        
        .upload-zone.active {
            border-color: #00ff00;
            background: #1f3f1f;
        }
        
        input[type="file"] {
            display: none;
        }
        
        select, input[type="text"] {
            width: 100%;
            padding: 12px;
            background: #222;
            border: 1px solid #444;
            color: #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 15px;
        }
        
        button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 12px 30px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #00cc00;
            transform: translateY(-2px);
        }
        
        button:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
            transform: none;
        }
        
        .status {
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 14px;
            margin: 10px 0;
        }
        
        .status.queued { background: #333; color: #aaa; }
        .status.processing { background: #1a3a4a; color: #5bc0de; }
        .status.completed { background: #1a3a1a; color: #00ff00; }
        .status.failed { background: #3a1a1a; color: #ff5555; }
        
        .job-item {
            background: #222;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 10px;
            border-left: 3px solid #444;
        }
        
        .job-item.completed { border-left-color: #00ff00; }
        .job-item.processing { border-left-color: #5bc0de; }
        .job-item.failed { border-left-color: #ff5555; }
        
        .job-meta {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        
        .log-entry {
            padding: 8px 12px;
            background: #1a1a1a;
            border-left: 2px solid #444;
            margin-bottom: 5px;
            font-size: 13px;
            font-family: 'Courier New', monospace;
        }
        
        .log-entry.error { border-left-color: #ff5555; color: #ffaaaa; }
        .log-entry.info { border-left-color: #5bc0de; }
        
        .download-link {
            color: #00ff00;
            text-decoration: none;
            font-weight: 600;
        }
        
        .download-link:hover {
            text-decoration: underline;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .section {
                padding: 15px;
            }
            
            h1 {
                font-size: 20px;
            }
        }
        
        /* Brand watermark styles */
        .brand-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 8px;
            margin-top: 12px;
        }
        .brand-checkbox {
            display: flex;
            align-items: center;
            gap: 6px;
            background: #222;
            padding: 8px 10px;
            border-radius: 6px;
            border: 1px solid #333;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
        }
        .brand-checkbox:hover {
            background: #2a2a2a;
            border-color: #00ff00;
        }
        .brand-checkbox input[type="checkbox"] {
            cursor: pointer;
        }
        .brand-checkbox input[type="checkbox"]:checked + span {
            color: #00ff00;
            font-weight: 600;
        }
        #watermarkStatus {
            margin-top: 15px;
        }
        .watermark-result {
            background: #222;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            border-left: 3px solid #00ff00;
        }
        
        /* Brand selector modal */
        .brand-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 9999;
            overflow-y: auto;
        }
        .brand-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .brand-modal-content {
            background: #1a1a1a;
            border: 2px solid #00ff00;
            border-radius: 8px;
            padding: 25px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        .brand-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        .brand-modal-close {
            background: #444;
            color: #fff;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
        }
        .brand-modal-close:hover {
            background: #ff5555;
        }
    </style>
</head>
<body>
    <div id="offlineBanner">‚ö° Portal is offline ‚Äî continuing in local mode</div>
    <header>
        <div class="container">
            <h1>‚ö° WatchTheFall Portal</h1>
            <div class="subtitle">Video Processing & Automation Control Panel</div>
        </div>
    </header>
    
    <div class="container">
        <!-- Multi-Link Downloader Section -->
        <div class="section">
            <h2>üîó Bulk Download & Upload</h2>
            <p style="color: #888; font-size: 14px; margin-bottom: 15px;">Paste up to 5 TikTok, Instagram, or X links (one per line) OR upload from your device</p>
            
            <div class="section">
                <h2>üì• Bulk Video Downloader</h2>
                <p style="color: #888; font-size: 14px; margin-bottom: 15px;">Paste TikTok/Instagram/X links ‚Ä¢ Download all at once ‚Ä¢ No login required</p>
                
                <textarea id="linksInput" placeholder="https://tiktok.com/@user/video/123...&#10;https://x.com/user/status/456..." 
                    style="width:100%; min-height:120px; background:#111; border:1px solid #333; color:#ddd; padding:12px; border-radius:8px; font-size:14px; font-family:monospace; resize:vertical;"></textarea>
                
                <div style="display:flex; gap:10px; margin-top:12px;">
                    <button id="fetchLinksBtn" style="flex:1; background:#00aa00;">üì• Download All Links</button>
                    <button id="pasteClipboardBtn" style="flex:1; background:#0066ff;">üìã Paste from Clipboard</button>
                    <button id="uploadFromDeviceBtn" style="flex:1; background:#ff6600;">üì± Upload from Device</button>
                    <button id="resetLinksBtn" style="flex:1; background:#444;">‚ôª Reset</button>
                </div>
                <label style="display:flex; align-items:center; gap:8px; margin-top:10px; font-size:13px; color:#aaa;">
                    <input type="checkbox" id="autoDownloadToggle"> Auto-download when ready
                </label>
                
                <!-- Hidden file input for device upload -->
                <input type="file" id="deviceVideoInput" accept="video/mp4,video/quicktime,video/webm" style="display:none;">
                
                <div id="fetchStatus" style="margin-top:15px;"></div>
            </div>
            
    </div>
    
    <!-- Brand Selector Modal -->
    <div id="brandModal" class="brand-modal">
        <div class="brand-modal-content">
            <div class="brand-modal-header">
                <h3 style="color:#00ff00; margin:0;">üé® Select Brands for Watermarking</h3>
                <div style="display:flex; gap:8px;">
                    <button class="brand-modal-minimize" onclick="minimizeBrandModal()" title="Minimize" style="background:#555; color:#fff; border:none; width:32px; height:32px; border-radius:4px; font-size:20px; cursor:pointer; display:flex; align-items:center; justify-content:center;">‚Äì</button>
                    <button class="brand-modal-close" onclick="closeBrandModal()">√ó</button>
                </div>
            </div>
            <div id="modalVideoName" style="color:#aaa; font-size:13px; margin-bottom:15px;"></div>
            
            <!-- Video Thumbnail Preview (Memory Efficient) -->
            <div style="margin-bottom:12px;">
                <div style="display:flex; gap:8px; margin-bottom:8px;">
                    <canvas id="modalThumb1" 
                            style="flex:1; height:180px; background:#000; border:1px solid #333; border-radius:8px; cursor:pointer;"
                            title="First frame"></canvas>
                    <canvas id="modalThumb2" 
                            style="flex:1; height:180px; background:#000; border:1px solid #333; border-radius:8px; cursor:pointer;"
                            title="Mid-point frame"></canvas>
                </div>
                <div style="text-align:center; color:#666; font-size:11px;">
                    üì∏ Preview: Start frame (left) ‚Ä¢ Middle frame (right)
                </div>
            </div>
            
            <p style="color:#888; font-size:14px; margin-bottom:15px;">Choose up to 10 brands to watermark this video. Each will be downloaded separately.</p>
            <p style="color:#0f0; font-size:13px; margin-bottom:15px; font-weight:600;">‚úÖ Smart Processing: Server handles one conversion at a time to ensure stability</p>
            
            <!-- Auto Download Toggle -->
            <div style="margin-bottom:15px; padding:10px; background:rgba(0,255,0,0.05); border:1px solid #333; border-radius:6px;">
                <label style="color:#aaa; font-size:13px; display:flex; align-items:center; cursor:pointer;">
                    <input type="checkbox" id="autoDownloadToggleModal" style="margin-right:8px;">
                    <span>üì• Auto-download videos when ready (may be blocked by browser)</span>
                </label>
                <div style="color:#666; font-size:11px; margin-top:4px;">üí° Tip: Manual download buttons shown for all videos</div>
            </div>
            
            <!-- Quality Preset Selector -->
            <div style="margin-bottom:15px; padding:10px; background:rgba(0,255,0,0.05); border:1px solid #333; border-radius:6px;">
                <label style="color:#aaa; font-size:13px; display:block; margin-bottom:6px;">‚ö° Quality Preset:</label>
                <select id="qualitySelect" style="width:100%; padding:6px; background:#1a1a1a; color:#0f0; border:1px solid #333; border-radius:4px;">
                    <option value="fast" selected>Fast (720p, 24fps, ~3Mbps) - Recommended for mobile</option>
                    <option value="balanced">Balanced (1080p, 27fps, ~4Mbps)</option>
                    <option value="high">High (1080p, 30fps, ~5Mbps)</option>
                    <option value="auto">Auto (Network & Device)</option>
                </select>
                <div id="qualityInfo" style="color:#666; font-size:11px; margin-top:4px;">üìä Fast preset selected (smoother playback)</div>
            </div>
            
            <div class="brand-grid" id="modalBrandGrid">
                <p style="color:#666;">Loading brands...</p>
            </div>
            <div style="margin-top:20px; display:flex; gap:10px;">
                <button id="modalGenerateBtn" style="flex:1; background:#00aa00;" disabled>‚ö° Generate Watermarked Videos</button>
                <button onclick="closeBrandModal()" style="flex:1; background:#444;">‚ùå Cancel</button>
            </div>
            <div id="modalStatus" style="margin-top:15px;"></div>
        </div>
    </div>
    
    <!-- Minimized Modal Bar Container (bottom of screen) -->
    <div id="minimizedModalsContainer" style="position:fixed; bottom:0; left:0; right:0; z-index:9999; pointer-events:none; padding:8px; display:flex; flex-direction:column; gap:8px;"></div>
    

    
    <script src="/portal/static/js/offline.js"></script>
    <script>
        let statusPollInterval = null;
        
        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/portal/static/sw.js').catch(() => {});
        }
        
        // 2Ô∏è‚É£ PATCH: UI Loads Instantly Without Waiting on Server
        // Initialize portal immediately, check server in background
        document.addEventListener('DOMContentLoaded', function() {
            initPortal(); // Run immediately
            safeTestCheck().then(() => {
                console.log('[OFFLINE] Server check completed');
                // Portal is already initialized, just update status if needed
            });
        });
        
        // Initialize portal function
        function initPortal() {
            // Instagram cookies section removed
        }
        
        // Instagram functionality removed
        
        // Process queued downloads periodically (every 8 seconds)
        setInterval(processQueuedDownloads, 8000);
        
        // 3Ô∏è‚É£ PATCH: Graceful Server Failure Handling
        window.addEventListener('unhandledrejection', (e) => {
          if (e.reason?.message?.includes('Failed to fetch')) {
            showToast('Server waking up ‚Äî UI still works.', 'warning');
            e.preventDefault();
          }
        });
        
        // Make showToast available globally
        window.showToast = showToast;
        
        // Stub function to fix mobile UI error
        window.loadRecentJobs = function() { return []; };
        
        // Auto-download toggle
        let autoDownloadEnabled = false;
        document.addEventListener('DOMContentLoaded', () => {
            const toggle = document.getElementById('autoDownloadToggle');
            if (toggle) {
                toggle.addEventListener('change', (e) => {
                    autoDownloadEnabled = !!e.target.checked;
                });
            }
        });
        
        // Paste-All button
        document.addEventListener('click', async (e) => {
            if (e.target && e.target.id === 'pasteClipboardBtn') {
                if (!navigator.clipboard) return;
                try {
                    const text = await navigator.clipboard.readText();
                    const urls = extractURLs(text).slice(0,5);
                    if (!urls.length) {
                        alert('No URLs found in clipboard');
                        return;
                    }
                    document.getElementById('linksInput').value = urls.join('\n');
                    document.getElementById('fetchStatus').innerHTML = '<div class="status queued">üìã Pasted URLs from clipboard.</div>';
                } catch (err) {
                    alert('Clipboard read failed');
                }
            }
            
            // Upload from device button
            if (e.target && e.target.id === 'uploadFromDeviceBtn') {
                document.getElementById('deviceVideoInput').click();
            }
        });
        
        // Handle device video upload
        document.getElementById('deviceVideoInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const statusDiv = document.getElementById('fetchStatus');
            statusDiv.innerHTML = `<div class="status processing">‚è≥ Uploading ${file.name}...</div>`;
            
            // Create a blob URL and immediately open the brand modal
            const blob = file;
            const url = URL.createObjectURL(blob);
            const filename = file.name;
            
            // Store for watermarking
            statusDiv.innerHTML = `<div class="status completed">‚úì Uploaded: ${filename} (${(file.size/(1024*1024)).toFixed(2)}MB)<br><a href="#" onclick="openBrandModalForUrl('${url}', '${filename}'); return false;" style="color:#0f0;">üé® Click to add watermarks</a></div>`;
            
            // Auto-open brand modal
            setTimeout(() => {
                openBrandModalForUrl(url, filename);
            }, 500);
            
            // Clear input
            e.target.value = '';
        });
        
        // Helpers
        function extractURLs(text) {
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            return (text.match(urlRegex) || []).map(u => u.trim());
        }
        
        async function shareVideo(downloadUrl, filename) {
            try {
                if (!navigator.share) {
                    alert('Sharing not supported on this browser');
                    return;
                }
                const res = await fetch(downloadUrl);
                const blob = await res.blob();
                const file = new File([blob], filename || 'video.mp4', { type: 'video/mp4' });
                if (navigator.canShare && navigator.canShare({ files: [file] })) {
                    await navigator.share({ files: [file], title: filename || 'Video' });
                } else {
                    // Fallback: share URL
                    await navigator.share({ title: filename || 'Video', url: downloadUrl });
                }
            } catch (e) {
                alert('Share failed: ' + e.message);
            }
        }
        
        // Download video with fetch-to-blob for reliability (cross-browser compatible)
        async function downloadVideo(url, filename, buttonIndex) {
            const button = document.getElementById(`dlBtn${buttonIndex}`);
            const originalText = button ? button.innerHTML : '';
            
            try {
                if (button) {
                    button.disabled = true;
                    button.innerHTML = '‚è≥ Downloading...';
                    button.style.background = '#666';
                }
                
                console.log('[DOWNLOAD] Fetching blob for:', filename);
                
                // Fetch the video as a blob
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const blob = await response.blob();
                console.log('[DOWNLOAD] Blob fetched:', blob.size, 'bytes');
                
                // Create a temporary blob URL
                const blobUrl = URL.createObjectURL(blob);
                
                // Create download link and trigger it
                const a = document.createElement('a');
                a.href = blobUrl;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                
                // Clean up
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(blobUrl);
                }, 100);
                
                if (button) {
                    button.innerHTML = '‚úì Downloaded!';
                    button.style.background = '#0a0';
                    setTimeout(() => {
                        button.disabled = false;
                        button.innerHTML = originalText;
                        button.style.background = '#00aa00';
                    }, 2000);
                }
                
                console.log('[DOWNLOAD] Download triggered for:', filename);
                
            } catch (err) {
                console.error('[DOWNLOAD ERROR]:', err);
                
                if (button) {
                    button.innerHTML = '‚ùå Failed - Try Again';
                    button.style.background = '#a00';
                    setTimeout(() => {
                        button.disabled = false;
                        button.innerHTML = originalText;
                        button.style.background = '#00aa00';
                    }, 3000);
                }
                
                // Fallback: try direct link open
                console.log('[DOWNLOAD] Fetch failed, trying direct link...');
                window.open(url, '_blank');
            }
        }
        
        // ========== QUICK ACTIONS: CapCut, Drive, Delete ==========
        
        // Open WebM in CapCut (mobile-only)
        function openInCapCut(blobUrl, filename) {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (!isMobile) {
                alert('üé¨ CapCut import is only available on mobile devices.\n\nOn desktop: Download the WebM and import manually.');
                return;
            }
            
            // Try CapCut deep link (may not work on all devices)
            const capCutUrl = `capcut://import?url=${encodeURIComponent(blobUrl)}`;
            window.location.href = capCutUrl;
            
            // Fallback: show instructions
            setTimeout(() => {
                const shouldDownload = confirm('üé¨ If CapCut didn\'t open, download the file manually?');
                if (shouldDownload) {
                    const a = document.createElement('a');
                    a.href = blobUrl;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                }
            }, 2000);
        }
        
        // Share to Google Drive
        function shareToGoogleDrive(blobUrl, filename) {
            // Google Drive doesn't support direct blob URL uploads
            // Best we can do is trigger download and show instructions
            
            const a = document.createElement('a');
            a.href = blobUrl;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
            
            // Show toast notification
            showToast(`‚òÅÔ∏è Download started! Upload to Drive manually from your Downloads folder.`, 'info');
            
            // Alternative: Open Drive in new tab
            setTimeout(() => {
                if (confirm('üìÇ Open Google Drive to upload manually?')) {
                    window.open('https://drive.google.com/drive/my-drive', '_blank');
                }
            }, 1000);
        }
        
        // Delete WebM from results
        function deleteWebM(blobUrl, idx) {
            if (!confirm('üóëÔ∏è Delete this WebM? You can always regenerate it.')) return;
            
            // Revoke blob URL to free memory
            URL.revokeObjectURL(blobUrl);
            
            // Remove result element
            const resultEl = document.getElementById(`result${idx}`);
            if (resultEl) {
                resultEl.style.transition = 'opacity 0.3s, transform 0.3s';
                resultEl.style.opacity = '0';
                resultEl.style.transform = 'scale(0.9)';
                setTimeout(() => resultEl.remove(), 300);
            }
            
            showToast('‚úÖ Deleted!', 'success');
            console.log(`[CLEANUP] Deleted WebM: ${blobUrl.substring(0, 50)}...`);
        }
        
        // Toast notification helper
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            const bgColors = { success: '#0a0', info: '#0af', warning: '#fa0', error: '#f55' };
            toast.style.cssText = `position:fixed; bottom:20px; right:20px; z-index:10000; background:${bgColors[type] || '#0af'}; color:#fff; padding:12px 20px; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.3); font-weight:600; animation:slideIn 0.3s ease-out;`;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.transition = 'opacity 0.3s';
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        // ========== AUTO CLEANUP: Delete old blob URLs from history (24h) ==========
        
        function cleanupOldWebMs() {
            const key = 'wtf_history';
            let hist = [];
            try { hist = JSON.parse(localStorage.getItem(key) || '[]'); } catch {}
            
            const now = Date.now();
            const oneDayMs = 24 * 60 * 60 * 1000;
            let deletedCount = 0;
            
            // Filter out entries older than 24 hours
            const cleaned = hist.filter(entry => {
                const age = now - (entry.ts || 0);
                if (age > oneDayMs && entry.url && entry.url.startsWith('blob:')) {
                    // Revoke blob URL
                    try {
                        URL.revokeObjectURL(entry.url);
                        deletedCount++;
                    } catch (e) {
                        console.warn('[CLEANUP] Failed to revoke blob:', e);
                    }
                    return false; // Remove from history
                }
                return true; // Keep
            });
            
            if (deletedCount > 0) {
                localStorage.setItem(key, JSON.stringify(cleaned));
                console.log(`[CLEANUP] ‚úÖ Deleted ${deletedCount} old WebM blob URLs (>24h old)`);
                renderHistory();
            } else {
                console.log('[CLEANUP] No old WebMs to delete');
            }
        }
        
        // Run cleanup on page load
        setTimeout(cleanupOldWebMs, 3000);
        
        // Run cleanup every 4 hours
        setInterval(cleanupOldWebMs, 4 * 60 * 60 * 1000);
        
        // Delegate click for share buttons and copy-all-links
        document.addEventListener('click', async (e) => {
            if (e.target && e.target.classList.contains('share-btn')) {
                const url = e.target.getAttribute('data-url');
                const name = e.target.getAttribute('data-filename') || 'video.mp4';
                await shareVideo(url, name);
            }
            if (e.target && e.target.id === 'copyAllLinksBtn') {
                const links = [];
                document.querySelectorAll('.download-link').forEach(a => {
                    if (a.href) links.push(a.href);
                });
                if (links.length) {
                    try {
                        await navigator.clipboard.writeText(links.join('\n'));
                        e.target.textContent = '‚úì Copied!';
                        setTimeout(() => { e.target.textContent = 'üìã Copy All Download Links'; }, 2000);
                    } catch (err) {
                        alert('Copy failed: ' + err.message);
                    }
                } else {
                    alert('No download links found');
                }
            }
        });
        
        function saveHistoryEntry(entry) {
            const key = 'wtf_history';
            let hist = [];
            try { hist = JSON.parse(localStorage.getItem(key) || '[]'); } catch {}
            hist.unshift({ ...entry, ts: Date.now() });
            hist = hist.slice(0,20);
            localStorage.setItem(key, JSON.stringify(hist));
            renderHistory();
        }
        function renderHistory() {
            const key = 'wtf_history';
            let hist = [];
            try { hist = JSON.parse(localStorage.getItem(key) || '[]'); } catch {}
            const container = document.getElementById('historyList');
            if (!container) return;
            if (!hist.length) {
                container.innerHTML = '<p style="color:#666;">No history yet</p>';
                return;
            }
            container.innerHTML = hist.map(h => `
                <div class="job-item">
                    <strong>${h.name || h.filename || 'Video'}</strong>
                    <div class="job-meta">${new Date(h.ts).toLocaleString()}${h.size_mb ? ` ‚Ä¢ ${h.size_mb}MB` : ''}
                    ${h.url ? `<br><a href="${h.url}" class="download-link" download="${h.name || 'video.mp4'}">üì• Download</a> <button class="share-btn" data-url="${h.url}" data-filename="${h.name || 'video.mp4'}" style="margin-left:8px;">ü§ù Share</button>` : ''}</div>
                </div>
            `).join('');
        }
        
        // ========== PHASE B: CLIENT-SIDE WATERMARK SYSTEM ==========
        let selectedVideoFile = null;
        let brandWatermarks = {};
        let brandsLoaded = false;
        let pendingVideoBlob = null;
        let pendingVideoFilename = null;
        let currentModalProgress = { current: 0, total: 0, brandName: '', percent: 0 };
        let isModalMinimized = false;
        
        // ========== TSS / BROWSER EXTENSION DETECTION ==========
        // Detect Trend Micro, HP Wolf, Microsoft Defender extensions that block uploads
        function detectSecurityExtensionInterference() {
            const warnings = [];
            
            // Check for TSS injection
            if (window.document.querySelector('script[src*="injection-tss"]') || 
                window.document.querySelector('script[src*="tss-mv3"]')) {
                warnings.push('‚ö†Ô∏è Trend Micro / HP Wolf Security detected - may block uploads');
            }
            
            // Check for runtime errors (TSS creates these)
            const originalError = console.error;
            let runtimeErrorDetected = false;
            console.error = function(...args) {
                if (args.some(a => String(a).includes('runtime.lastError') || String(a).includes('Receiving end does not exist'))) {
                    runtimeErrorDetected = true;
                }
                originalError.apply(console, args);
            };
            
            // Check for excessive URL.createObjectURL calls being intercepted
            if (performance && performance.getEntriesByType) {
                const resources = performance.getEntriesByType('resource');
                const tssResources = resources.filter(r => r.name.includes('injection-tss') || r.name.includes('tss-mv3'));
                if (tssResources.length > 0) {
                    warnings.push('‚ö†Ô∏è Security extension detected interfering with MediaRecorder');
                }
            }
            
            return warnings;
        }
        
        // Show warning banner if interference detected
        function showExtensionWarning() {
            const warnings = detectSecurityExtensionInterference();
            if (warnings.length === 0) return;
            
            const banner = document.createElement('div');
            banner.id = 'extensionWarning';
            banner.style.cssText = 'position:fixed; top:60px; left:50%; transform:translateX(-50%); z-index:10000; background:#ff6600; color:#000; padding:16px 24px; border-radius:8px; box-shadow:0 4px 12px rgba(255,102,0,0.5); max-width:90%; font-weight:600; text-align:center; animation:slideDown 0.3s ease-out;';
            banner.innerHTML = `
                <div style="margin-bottom:8px;">${warnings.join('<br>')}</div>
                <div style="font-size:12px; font-weight:normal; color:#1a1a1a;">‚úÖ Fix: Disable browser security extensions OR use Incognito mode</div>
                <button onclick="this.parentElement.remove()" style="margin-top:8px; background:#000; color:#0f0; border:none; padding:6px 12px; border-radius:4px; cursor:pointer; font-weight:600;">Got it</button>
            `;
            document.body.appendChild(banner);
            
            console.warn('[TSS DETECTION]', warnings.join(', '));
        }
        
        // Enhanced video loading with TSS workaround
        async function loadVideoSafely(videoElement, videoFile) {
            return new Promise((resolve, reject) => {
                // Try multiple approaches for TSS compatibility
                let attempts = 0;
                const maxAttempts = 3;
                
                const tryLoad = () => {
                    attempts++;
                    console.log(`[VIDEO LOAD] Attempt ${attempts}/${maxAttempts}`);
                    
                    // Clear any existing source
                    videoElement.src = '';
                    
                    // Create blob URL
                    const blobUrl = URL.createObjectURL(videoFile);
                    
                    // Add error handling
                    videoElement.onloadedmetadata = () => {
                        console.log('[VIDEO LOAD] Success');
                        resolve();
                    };
                    
                    videoElement.onerror = (err) => {
                        console.error(`[VIDEO LOAD] Error on attempt ${attempts}:`, err);
                        URL.revokeObjectURL(blobUrl);
                        
                        if (attempts < maxAttempts) {
                            // Wait before retry
                            setTimeout(tryLoad, 100 * attempts);
                        } else {
                            reject(new Error('Failed to load video after multiple attempts'));
                        }
                    };
                    
                    // Set source
                    videoElement.src = blobUrl;
                };
                
                tryLoad();
            });
        }
        
        // Run detection after page load
        setTimeout(showExtensionWarning, 2000);
        
        // Quality preset detection
        function getQualityPreset() {
            const selected = document.getElementById('qualitySelect')?.value;
            
            // Manual selection overrides auto
            if (selected && selected !== 'auto') {
                const presets = {
                    fast: { name: 'Fast', width: 720, height: 1280, fps: 24, bitrate: 3000000 },
                    balanced: { name: 'Balanced', width: 1080, height: 1920, fps: 27, bitrate: 4000000 },
                    high: { name: 'High', width: 1080, height: 1920, fps: 30, bitrate: 5000000 }
                };
                return presets[selected];
            }
            
            // Auto detection
            const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            const memory = navigator.deviceMemory || 4;
            const cores = navigator.hardwareConcurrency || 4;
            
            let preset = 'balanced';
            let reason = 'default';
            
            if (conn) {
                const effectiveType = conn.effectiveType;
                const downlink = conn.downlink || 5;
                const rtt = conn.rtt || 100;
                const saveData = conn.saveData || false;
                
                if (saveData || effectiveType === 'slow-2g' || effectiveType === '2g' || downlink < 2 || rtt > 300) {
                    preset = 'fast';
                    reason = `${effectiveType || 'slow network'}`;
                } else if (effectiveType === '3g' || downlink < 5 || rtt > 200) {
                    preset = 'balanced';
                    reason = effectiveType || '3g';
                } else if (effectiveType === '4g' && downlink >= 5 && rtt <= 200) {
                    preset = 'high';
                    reason = '4g, good signal';
                }
            }
            
            // Downgrade for low-end devices
            if (memory < 4 || cores < 4) {
                if (preset === 'high') preset = 'balanced';
                else if (preset === 'balanced') preset = 'fast';
                reason += `, low device memory/cores`;
            }
            
            const presets = {
                fast: { name: 'Fast', width: 720, height: 1280, fps: 24, bitrate: 3000000 },
                balanced: { name: 'Balanced', width: 1080, height: 1920, fps: 27, bitrate: 4000000 },
                high: { name: 'High', width: 1080, height: 1920, fps: 30, bitrate: 5000000 }
            };
            
            const result = presets[preset];
            result.reason = reason;
            return result;
        }
        
        // Codec detection - find best supported codec for device (fixes laptop compatibility)
        function getSupportedCodec() {
            // Test codecs in order of preference (best quality first)
            const codecs = [
                'video/webm;codecs=vp9,opus',     // VP9 - best quality
                'video/webm;codecs=vp8,opus',     // VP8 - wider support
                'video/webm;codecs=vp9',          // VP9 without audio codec
                'video/webm;codecs=vp8',          // VP8 without audio codec
                'video/webm'                       // Generic fallback
            ];
            
            for (const codec of codecs) {
                if (MediaRecorder.isTypeSupported(codec)) {
                    console.log(`[CODEC] Using: ${codec}`);
                    return codec;
                }
            }
            
            // Ultimate fallback - try any WebM
            console.warn('[CODEC] No preferred codec supported, using generic video/webm');
            return 'video/webm';
        }
        
        // Brand modal functions
        function closeBrandModal() {
            document.getElementById('brandModal').classList.remove('active');
            document.querySelectorAll('.modal-brand-check').forEach(cb => cb.checked = false);
            document.getElementById('modalStatus').innerHTML = '';
            
            // Clear thumbnail canvases
            const canvas1 = document.getElementById('modalThumb1');
            const canvas2 = document.getElementById('modalThumb2');
            if (canvas1) {
                const ctx1 = canvas1.getContext('2d');
                ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
            }
            if (canvas2) {
                const ctx2 = canvas2.getContext('2d');
                ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
            }
            
            // Remove minimized bar if exists
            const minimizedBar = document.getElementById('minimizedModalBar');
            if (minimizedBar) minimizedBar.remove();
            isModalMinimized = false;
            
            pendingVideoBlob = null;
            pendingVideoFilename = null;
        }
        
        function minimizeBrandModal() {
            const modal = document.getElementById('brandModal');
            const container = document.getElementById('minimizedModalsContainer');
            
            // Hide modal
            modal.classList.remove('active');
            isModalMinimized = true;
            
            // Create minimized bar if it doesn't exist
            let minimizedBar = document.getElementById('minimizedModalBar');
            if (!minimizedBar) {
                minimizedBar = document.createElement('div');
                minimizedBar.id = 'minimizedModalBar';
                minimizedBar.style.cssText = 'background:#1a1a1a; border:2px solid #0f0; border-radius:8px; padding:12px; cursor:pointer; pointer-events:auto; box-shadow:0 -2px 10px rgba(0,255,0,0.3);';
                minimizedBar.onclick = maximizeBrandModal;
                container.appendChild(minimizedBar);
            }
            
            updateMinimizedBar();
        }
        
        function maximizeBrandModal() {
            const modal = document.getElementById('brandModal');
            isModalMinimized = false;
            modal.classList.add('active');
        }
        
        function updateMinimizedBar() {
            const minimizedBar = document.getElementById('minimizedModalBar');
            if (!minimizedBar || !isModalMinimized) return;
            
            const { current, total, brandName, percent } = currentModalProgress;
            
            let statusText = `üé¨ ${pendingVideoFilename || 'Video'}`;
            if (total > 0) {
                statusText = `‚è≥ ${current}/${total}: ${brandName} - ${percent}%`;
            }
            
            minimizedBar.innerHTML = `
                <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
                    <div style="flex:1; min-width:0;">
                        <div style="color:#0f0; font-weight:bold; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${statusText}</div>
                        ${total > 0 ? `
                            <div style="background:#333; border-radius:4px; overflow:hidden; height:6px; margin-top:4px;">
                                <div style="background:#0f0; height:100%; width:${percent}%; transition:width 0.3s;"></div>
                            </div>
                        ` : ''}
                    </div>
                    <div style="color:#888; font-size:11px;">üëÜ Tap to open</div>
                </div>
            `;
        }
        
        async function openBrandModalForUrl(videoUrl, filename) {
            try {
                console.log('[MODAL] Opening brand modal for:', filename);
                console.log('[MODAL] Brands loaded:', brandsLoaded);
                console.log('[MODAL] Brand count:', Object.keys(brandWatermarks).length);
                
                // Wait for brands to load first
                if (!brandsLoaded) {
                    alert('Loading brands... please wait a moment and try again.');
                    return;
                }
                
                // Detect quality preset and show info
                const preset = getQualityPreset();
                const qualityInfoDiv = document.getElementById('qualityInfo');
                const selectedValue = document.getElementById('qualitySelect')?.value;
                
                if (selectedValue === 'auto' && preset.reason) {
                    qualityInfoDiv.textContent = `üìä Auto: ${preset.name} (${preset.width}x${preset.height}, ${preset.fps}fps) - ${preset.reason}`;
                } else {
                    qualityInfoDiv.textContent = `üìä ${preset.name}: ${preset.width}x${preset.height}, ${preset.fps}fps, ~${(preset.bitrate/1000000).toFixed(1)}Mbps`;
                }
                
                // Fetch video as blob
                document.getElementById('modalVideoName').textContent = `üé¨ Loading: ${filename}...`;
                document.getElementById('brandModal').classList.add('active');
                
                // Debug: Check if grid has content
                const gridHTML = document.getElementById('modalBrandGrid').innerHTML;
                console.log('[MODAL] Grid HTML length:', gridHTML.length);
                console.log('[MODAL] Grid first 200 chars:', gridHTML.substring(0, 200));
                
                const response = await fetch(videoUrl);
                if (!response.ok) throw new Error('Failed to load video');
                
                pendingVideoBlob = await response.blob();
                pendingVideoFilename = filename;
                
                // Generate thumbnails (memory efficient - no video element kept in DOM)
                const tempVideo = document.createElement('video');
                tempVideo.muted = true;
                tempVideo.volume = 0; // Extra safety: force volume to 0
                tempVideo.preload = 'metadata'; // Only load metadata, not audio buffer
                
                await loadVideoSafely(tempVideo, pendingVideoBlob);
                
                const duration = tempVideo.duration;
                const canvas1 = document.getElementById('modalThumb1');
                const canvas2 = document.getElementById('modalThumb2');
                const ctx1 = canvas1.getContext('2d');
                const ctx2 = canvas2.getContext('2d');
                
                // Set canvas dimensions to match video aspect ratio
                const aspectRatio = tempVideo.videoWidth / tempVideo.videoHeight;
                canvas1.width = 180 * aspectRatio;
                canvas1.height = 180;
                canvas2.width = 180 * aspectRatio;
                canvas2.height = 180;
                
                // Capture first frame (0.1s) - ensure paused
                tempVideo.pause();
                tempVideo.currentTime = 0.1;
                await new Promise(res => { tempVideo.onseeked = res; });
                ctx1.drawImage(tempVideo, 0, 0, canvas1.width, canvas1.height);
                
                // Capture middle frame - keep paused
                tempVideo.currentTime = duration / 2;
                await new Promise(res => { tempVideo.onseeked = res; });
                ctx2.drawImage(tempVideo, 0, 0, canvas2.width, canvas2.height);
                
                // Clean up temp video immediately
                tempVideo.remove();
                tempVideo.src = '';
                tempVideo.load();
                
                const durationStr = duration ? ` ‚Ä¢ ${Math.floor(duration)}s` : '';
                document.getElementById('modalVideoName').textContent = `üé¨ ${filename} (${(pendingVideoBlob.size/(1024*1024)).toFixed(2)}MB${durationStr})`;
                
                console.log('[MODAL] Thumbnails generated, video element cleaned up');
            } catch (err) {
                console.error('[MODAL] Error:', err);
                
                // Check if this is a TSS-related error
                if (err.message.includes('TSS') || err.message.includes('security') || err.message.includes('extension')) {
                    alert('Failed to load video due to browser security extension interference. Please disable security extensions or try Incognito mode.');
                } else {
                    alert('Failed to load video: ' + err.message);
                }
                
                closeBrandModal();
            }
        }
        
        // Intercept download link clicks
        document.addEventListener('click', (e) => {
            if (e.target && e.target.classList.contains('download-link')) {
                e.preventDefault();
                const url = e.target.getAttribute('href');
                const filename = e.target.getAttribute('download') || 'video.mp4';
                openBrandModalForUrl(url, filename);
            }
        });
        
        // Load brand watermarks config
        loadBrandConfig()
            .then(brands => {
                brandWatermarks = brands;
                
                // Populate main brand grid
                const grid = document.getElementById('brandGrid');
                grid.innerHTML = Object.keys(brands).map((brandName, idx) => `
                    <label class="brand-checkbox">
                        <input type="checkbox" class="brand-check" value="${brandName}" data-file="${brands[brandName]}">
                        <span>${brandName}</span>
                    </label>
                `).join('');
                
                // Populate modal brand grid
                const modalGrid = document.getElementById('modalBrandGrid');
                modalGrid.innerHTML = Object.keys(brands).map((brandName, idx) => `
                    <label class="brand-checkbox">
                        <input type="checkbox" class="modal-brand-check" value="${brandName}" data-file="${brands[brandName]}">
                        <span>${brandName}</span>
                    </label>
                `).join('');
                
                console.log(`[BRANDS] Loaded ${Object.keys(brands).length} brands into modal grid`);
                brandsLoaded = true;
                
                // Enable/disable button based on selection (main section)
                document.querySelectorAll('.brand-check').forEach(cb => {
                    cb.addEventListener('change', () => {
                        const selected = document.querySelectorAll('.brand-check:checked').length;
                        const applyBtn = document.getElementById('applyWatermarksBtn');
                        applyBtn.disabled = !(selectedVideoFile && selected > 0 && selected <= 10);
                        if (selected > 10) {
                            alert('Maximum 10 brands at a time');
                            cb.checked = false;
                        }
                    });
                });
                
                // Enable/disable button based on selection (modal)
                document.querySelectorAll('.modal-brand-check').forEach(cb => {
                    cb.addEventListener('change', () => {
                        const selected = document.querySelectorAll('.modal-brand-check:checked').length;
                        const generateBtn = document.getElementById('modalGenerateBtn');
                        generateBtn.disabled = !(selected > 0 && selected <= 10);
                        if (selected > 10) {
                            alert('Maximum 10 brands at a time');
                            cb.checked = false;
                        }
                    });
                });
            })
            .catch(err => {
                console.error('[BRANDS] Failed to load brands.json:', err);
                alert('Failed to load brand list. Please refresh the page.');
            });
        
        // Modal Generate button handler - sequential processing with retry logic
        document.getElementById('modalGenerateBtn').addEventListener('click', async () => {
            const selected = Array.from(document.querySelectorAll('.modal-brand-check:checked'));
            if (!pendingVideoBlob || !selected.length) return;
            
            const statusDiv = document.getElementById('modalStatus');
            const preset = getQualityPreset();
            const autoDownload = document.getElementById('autoDownloadToggleModal')?.checked || false;
            
            // Show initial status
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            statusDiv.innerHTML = `<div class="status processing">‚è≥ Initializing processing...<br><small style="color:#888;">‚ö° Quality: ${preset.name} (${preset.width}x${preset.height}, ${preset.fps}fps) | ${selected.length} brands selected</small></div>`;
            document.getElementById('modalGenerateBtn').disabled = true;
            
            const results = [];
            const totalBrands = selected.length;
            
            // Helper: Direct WebM download (no server conversion - instant!)
            async function downloadWebM(watermarkedBlob, brandName, index) {
                const webmFilename = `${brandName}_${pendingVideoFilename.replace(/\.[^/.]+$/, '')}.webm`;
                const webmUrl = URL.createObjectURL(watermarkedBlob);
                const sizeMB = (watermarkedBlob.size / (1024 * 1024)).toFixed(2);
                
                console.log(`[WEBM] Generated download for ${brandName}: ${webmFilename} (${sizeMB}MB)`);
                
                return new Promise((resolve) => {
                    // Instant success - no upload needed!
                    resolve({
                        success: true,
                        brandName,
                        url: webmUrl,
                        filename: webmFilename,
                        size_mb: parseFloat(sizeMB),
                        isWebM: true
                    });
                });
            }
            
            // Process brands in batches
            for (let i = 0; i < totalBrands; i++) {
                const brandName = selected[i].value;
                const watermarkFile = selected[i].getAttribute('data-file');
                
                // DEBUG: Log brand mapping
                console.log(`[BRAND ${i+1}/${totalBrands}] Selected: "${brandName}" -> File: "${watermarkFile}"`);
                
                currentModalProgress = { current: i + 1, total: totalBrands, brandName, percent: 0 };
                
                try {
                    // Stage 1: Watermark rendering
                    const progressHTML = `
                        <div class="status processing">
                            ‚è≥ Processing ${i + 1}/${totalBrands}: <strong>${brandName}</strong><br>
                            <div style="background:#333; border-radius:4px; overflow:hidden; height:10px; margin:8px 0;">
                                <div id="progressBar${i}" style="background:linear-gradient(90deg, #0f0, #0aa); height:100%; width:0%; transition:width 0.3s;"></div>
                            </div>
                            <small id="progressText${i}" style="color:#888; display:block; margin-top:4px;">Applying watermark...</small>
                        </div>
                    `;
                    statusDiv.innerHTML = progressHTML;
                    updateMinimizedBar();
                    
                    const videoFile = new File([pendingVideoBlob], pendingVideoFilename, { type: pendingVideoBlob.type });
                    const watermarkedBlob = await applyWatermarkToVideo(videoFile, watermarkFile, brandName, (progress) => {
                        const bar = document.getElementById(`progressBar${i}`);
                        const text = document.getElementById(`progressText${i}`);
                        if (bar) bar.style.width = `${progress}%`;
                        if (text) text.textContent = `Watermark ${progress}% complete`;
                        currentModalProgress.percent = progress;
                        updateMinimizedBar();
                    });
                    
                    // Direct WebM download (no server conversion!)
                    statusDiv.innerHTML = `<div class="status processing">‚úÖ Watermarked ${i + 1}/${totalBrands}: <strong>${brandName}</strong><br><small style="color:#0f0;">Generating download link...</small></div>`;
                    updateMinimizedBar();
                    
                    const result = await downloadWebM(watermarkedBlob, brandName, i);
                    
                    results.push(result);
                    saveHistoryEntry({ type: 'watermark', name: result.filename, url: result.url, size_mb: result.size_mb });
                    
                } catch (err) {
                    console.error(`[WATERMARK ERROR] ${brandName}:`, err);
                    
                    const is429 = err.message.includes('busy') || err.message.includes('429');
                    const is50x = err.message.includes('500') || err.message.includes('502') || err.message.includes('Server error');
                    
                    let errorMsg = err.message || String(err);
                    if (is429) {
                        errorMsg = 'Server was too busy after multiple retries. Try again in a moment.';
                    } else if (is50x) {
                        errorMsg = 'Server overload or crash. Try shorter videos or wait for server to restart.';
                    }
                    
                    results.push({ 
                        brandName, 
                        error: errorMsg,
                        errorDetails: `üö´ ${err.name || 'Error'}: ${errorMsg}<br><small style="color:#888;">${is429 || is50x ? 'Skipped this brand - continuing with others' : err.stack ? err.stack.split('\n')[0] : ''}</small>`
                    });
                }
            }
            
            // Show final results
            const successCount = results.filter(r => r.success).length;
            const failedCount = results.filter(r => r.error).length;
            const items = results.map((r, idx) => {
                if (r.error) {
                    return `<div class="watermark-result" style="border-left-color:#ff5555; padding:15px;">‚úó <strong>${r.brandName}</strong><br>${r.errorDetails || r.error}</div>`;
                }
                return `<div class="watermark-result" id="result${idx}">
                    ‚úì <strong>${r.brandName}</strong> (${r.size_mb}MB WebM)<br>
                    <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:12px;">
                        <button onclick="downloadVideo('${r.url}', '${r.filename}', ${idx})" id="dlBtn${idx}" style="flex:1; min-width:120px; padding:10px 12px; background:#00aa00; color:#000; border:none; border-radius:6px; font-weight:600; cursor:pointer; font-size:13px;">üì• Save</button>
                        <button onclick="openInCapCut('${r.url}', '${r.filename}')" style="flex:1; min-width:120px; padding:10px 12px; background:#ff6600; color:#fff; border:none; border-radius:6px; font-weight:600; cursor:pointer; font-size:13px;">üé¨ CapCut</button>
                        <button onclick="shareToGoogleDrive('${r.url}', '${r.filename}')" style="flex:1; min-width:120px; padding:10px 12px; background:#4285f4; color:#fff; border:none; border-radius:6px; font-weight:600; cursor:pointer; font-size:13px;">‚òÅÔ∏è Drive</button>
                        <button onclick="deleteWebM('${r.url}', ${idx})" style="padding:10px 12px; background:#ff5555; color:#fff; border:none; border-radius:6px; font-weight:600; cursor:pointer; font-size:13px;">üóëÔ∏è</button>
                    </div>
                    <small style="color:#888; margin-top:8px; display:block;">üí° Export from CapCut as MP4 for Instagram/TikTok</small>
                </div>`;
            }).join('');
            
            const summaryColor = failedCount === 0 ? '#0f0' : (successCount > 0 ? '#ff6600' : '#ff5555');
            statusDiv.innerHTML = `<div class="status completed">‚úì Complete: ${successCount} successful, ${failedCount} failed<br><small style="color:${summaryColor}; margin-top:8px; display:block; font-weight:600;">üëá Click each button to download WebM (no server conversion needed!):</small></div>${items}`;
            
            // Auto-download if enabled
            if (autoDownload && successCount > 0) {
                console.log('[AUTO-DOWNLOAD] Starting auto-download for', successCount, 'videos');
                for (let idx = 0; idx < results.length; idx++) {
                    if (results[idx].success) {
                        // Small delay between downloads to avoid browser blocking
                        await new Promise(r => setTimeout(r, 500));
                        downloadVideo(results[idx].url, results[idx].filename, idx);
                    }
                }
            }
            
            currentModalProgress = { current: 0, total: 0, brandName: '', percent: 0 };
            updateMinimizedBar();
            
            console.log(`[BATCH COMPLETE] ${successCount}/${totalBrands} brands successful`);
            
            renderHistory();
            document.getElementById('modalGenerateBtn').disabled = false;
        });
        
        // Select video file
        document.getElementById('selectVideoBtn').addEventListener('click', () => {
            document.getElementById('watermarkVideoInput').click();
        });
        
        document.getElementById('watermarkVideoInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            selectedVideoFile = file;
            document.getElementById('selectedVideoName').textContent = `‚úì Selected: ${file.name} (${(file.size/(1024*1024)).toFixed(2)}MB)`;
            const selected = document.querySelectorAll('.brand-check:checked').length;
            document.getElementById('applyWatermarksBtn').disabled = !(selected > 0 && selected <= 10);
        });
        
        // Apply watermarks (Canvas-based with adaptive opacity 10-20%)
        document.getElementById('applyWatermarksBtn').addEventListener('click', async () => {
            const selected = Array.from(document.querySelectorAll('.brand-check:checked'));
            if (!selectedVideoFile || !selected.length) return;
            
            const statusDiv = document.getElementById('watermarkStatus');
            statusDiv.innerHTML = '<div class="status processing">‚è≥ Processing watermarks...</div>';
            document.getElementById('applyWatermarksBtn').disabled = true;
            
            const results = [];
            
            for (let i = 0; i < selected.length; i++) {
                const brandName = selected[i].value;
                const watermarkFile = selected[i].getAttribute('data-file');
                
                try {
                    statusDiv.innerHTML = `<div class="status processing">‚è≥ Processing ${i+1}/${selected.length}: ${brandName}...</div>`;
                    
                    const watermarkedBlob = await applyWatermarkToVideo(selectedVideoFile, watermarkFile, brandName);
                    const url = URL.createObjectURL(watermarkedBlob);
                    // Use .webm extension for proper file type recognition
                    const filename = `${brandName}_${selectedVideoFile.name.replace(/\.[^/.]+$/, '')}.webm`;
                    
                    results.push({ brandName, url, filename, size_mb: (watermarkedBlob.size/(1024*1024)).toFixed(2) });
                    
                    // Save to history
                    saveHistoryEntry({ type: 'watermark', name: filename, url, size_mb: (watermarkedBlob.size/(1024*1024)).toFixed(2) });
                    
                } catch (err) {
                    results.push({ brandName, error: err.message });
                }
            }
            
            // Show results
            const successCount = results.filter(r => !r.error).length;
            const items = results.map(r => {
                if (r.error) {
                    return `<div class="watermark-result" style="border-left-color:#ff5555;">‚úó ${r.brandName}: ${r.error}</div>`;
                }
                return `<div class="watermark-result">‚úì <strong>${r.brandName}</strong><br><a href="${r.url}" download="${r.filename}" class="download-link">üì• ${r.filename}</a> <span style="color:#666;">(${r.size_mb}MB)</span> <button class="share-btn" data-url="${r.url}" data-filename="${r.filename}" style="margin-left:8px;">ü§ù Share</button></div>`;
            }).join('');
            
            statusDiv.innerHTML = `<div class="status completed">‚úì Generated ${successCount}/${results.length} watermarked videos</div>${items}`;
            
            // Auto-download if enabled
            if (autoDownloadEnabled) {
                results.filter(r => !r.error).forEach(r => {
                    const a = document.createElement('a');
                    a.href = r.url;
                    a.download = r.filename;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                });
            }
            
            document.getElementById('applyWatermarksBtn').disabled = false;
        });
        
        // FFmpeg.WASM-based watermark application
        async function applyWatermarkToVideo(videoFile, watermarkFileName, brandName, onProgress = null) {
            // 6Ô∏è‚É£ PATCH: Watermarker Always Works, Even Without Server
            if (!videoFile) {
                showToast('Video unavailable ‚Äî try reloading it.', 'error');
                return Promise.reject(new Error('Video unavailable'));
            }
            
            try {
                if (onProgress) onProgress(5);
                
                // Load FFmpeg core
                const { createFFmpeg, fetchFile } = FFmpeg;
                const ffmpeg = createFFmpeg({ log: true });
                
                // Load FFmpeg core if not already loaded
                if (!ffmpeg.isLoaded()) {
                    await ffmpeg.load();
                }
                
                if (onProgress) onProgress(15);
                
                // Write input video to FFmpeg FS
                const videoArrayBuffer = await videoFile.arrayBuffer();
                ffmpeg.FS('writeFile', 'input.mp4', new Uint8Array(videoArrayBuffer));
                
                if (onProgress) onProgress(25);
                
                // Fetch watermark image and write to FFmpeg FS
                const watermarkResponse = await fetch(`/portal/static/watermarks/${watermarkFileName}`);
                const watermarkArrayBuffer = await watermarkResponse.arrayBuffer();
                ffmpeg.FS('writeFile', 'watermark.png', new Uint8Array(watermarkArrayBuffer));
                
                if (onProgress) onProgress(35);
                
                // Run FFmpeg command to apply watermark
                // Using a simple overlay at top-right corner with some padding
                await ffmpeg.run(
                    '-i', 'input.mp4',
                    '-i', 'watermark.png',
                    '-filter_complex', '[0:v][1:v]overlay=W-w-20:20',
                    '-c:a', 'copy',
                    '-f', 'webm',
                    'output.webm'
                );
                
                if (onProgress) onProgress(85);
                
                // Read output file
                const outputData = ffmpeg.FS('readFile', 'output.webm');
                
                // Create blob from output data
                const outputBlob = new Blob([outputData.buffer], { type: 'video/webm' });
                
                if (onProgress) onProgress(100);
                
                return outputBlob;
            } catch (err) {
                console.error('[WATERMARK] FFmpeg error:', err);
                throw new Error(`Watermark processing failed: ${err.message}`);
            }
        }
        // ========== END PHASE B ==========
        
        // Helpers (fetch batch + paste/drag + reset)
        // 4Ô∏è‚É£ PATCH: Download Queue Works Offline
        function queueDownload(url) {
            const q = JSON.parse(localStorage.getItem('download_queue') || '[]');
            q.push({ url, timestamp: Date.now() });
            localStorage.setItem('download_queue', JSON.stringify(q));
            console.log('[OFFLINE] Queued download:', url);
            showToast('Download queued - will process when online', 'info');
        }
        
        function fetchBatch() {
            const batch = JSON.parse(localStorage.getItem('watermark_batch') || '[]');
            return batch;
        }
        
        function pasteOrDrag(event) {
            event.preventDefault();
            const items = (event.clipboardData || event.dataTransfer).items;
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (item.type.startsWith('video/')) {
                    const videoFile = item.getAsFile();
                    if (videoFile) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            const videoBlob = new Blob([e.target.result], { type: 'video/mp4' });
                            const videoUrl = URL.createObjectURL(videoBlob);
                            const video = document.createElement('video');
                            video.src = videoUrl;
                            video.controls = true;
                            video.style.maxWidth = '100%';
                            video.style.marginTop = '16px';
                            document.getElementById('videoContainer').appendChild(video);
                            document.getElementById('videoContainer').style.display = 'block';
                            document.getElementById('applyWatermarksBtn').disabled = false;
                        };
                        reader.readAsArrayBuffer(videoFile);
                    }
                }
            }
        }
        
        function reset() {
            document.getElementById('videoContainer').innerHTML = '';
            document.getElementById('applyWatermarksBtn').disabled = true;
            document.getElementById('status').innerHTML = '';
        }

        async function processQueuedDownloads() {
            const q = JSON.parse(localStorage.getItem('download_queue') || '[]');
            if (q.length === 0) return;
            
            console.log(`[OFFLINE] Processing ${q.length} queued downloads...`);
            const remaining = [];

            for (const item of q) {
                // Check if item is older than 24 hours
                if (Date.now() - item.timestamp > 24 * 60 * 60 * 1000) {
                    console.log('[OFFLINE] Skipping old queued download:', item.url);
                    continue;
                }
                
                const res = await safeFetch('/api/videos/fetch', {
                    method: 'POST',
                    body: JSON.stringify({ urls: [item.url] }),
                    headers: { 'Content-Type': 'application/json' }
                });

                if (!res.ok) {
                    remaining.push(item);
                    console.log('[OFFLINE] Re-queuing failed download:', item.url);
                } else {
                    console.log('[OFFLINE] Successfully processed queued download:', item.url);
                    // Show notification or update UI as needed
                }
            }

            localStorage.setItem('download_queue', JSON.stringify(remaining));
            if (remaining.length > 0) {
                console.log(`[OFFLINE] ${remaining.length} downloads still queued`);
            }
        }

        async function fetchBatchUrls(targetUrls) {
            const response = await safeFetch('/api/videos/fetch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ urls: targetUrls })
            });
            if (!response.ok) {
                const text = await response.text();
                throw new Error(`Server error (${response.status}): ${text}`);
            }
            return await response.json();
        }
        function autoDownloadFile(url, filename) {
            const a = document.createElement('a');
            a.href = url;
            a.download = filename || 'video.mp4';
            document.body.appendChild(a);
            a.click();
            a.remove();
        }
        (function(){
            const linksInput = document.getElementById('linksInput');
            const fetchStatus = document.getElementById('fetchStatus');
            const resetBtn = document.getElementById('resetLinksBtn');
            if (resetBtn) {
                resetBtn.addEventListener('click', ()=>{
                    if (linksInput) linksInput.value = '';
                    if (fetchStatus) fetchStatus.innerHTML = '';
                });
            }
            if (linksInput) {
                // Paste-to-start
                linksInput.addEventListener('paste', async (e) => {
                    const text = (e.clipboardData && e.clipboardData.getData('text')) || '';
                    const urls = extractURLs(text).slice(0,5);
                    if (!urls.length) return;
                    e.preventDefault();
                    
                    if (urls.length === 1) {
                        fetchStatus.innerHTML = '<div class="status processing">‚è≥ Downloading 1 video...</div>';
                        try {
                            const result = await fetchBatchUrls(urls);
                            const r = result.results && result.results[0];
                            if (result.success && r && r.success) {
                                saveHistoryEntry({ type: 'link', name: r.filename, url: r.download_url, size_mb: r.size_mb });
                                fetchStatus.innerHTML = `<div class="status completed">‚úì Downloaded <a href="${r.download_url}" class="download-link" download="${r.filename}">${r.filename}</a> <span style="color:#666;">(${r.size_mb}MB)</span> <button class="share-btn" data-url="${r.download_url}" data-filename="${r.filename}" style="margin-left:8px;">ü§ù Share</button></div>`;
                                if (autoDownloadEnabled) autoDownloadFile(r.download_url, r.filename);
                                renderHistory();
                            } else {
                                fetchStatus.innerHTML = `<div class=\"status failed\">‚úó Error: ${r && r.error ? r.error : 'Download failed'}</div>`;
                            }
                        } catch (err) {
                            fetchStatus.innerHTML = `<div class=\"status failed\">‚úó Error: ${err.message}</div>`;
                        } finally {
                            linksInput.value = '';
                        }
                    } else {
                        linksInput.value = urls.join('\n');
                        fetchStatus.innerHTML = `<div class=\"status queued\">üìã ${urls.length} URLs pasted. Tap \"Download All Links\".</div>`;
                    }
                });
                // Drag & drop URLs
                linksInput.addEventListener('dragover', (e)=>{ e.preventDefault(); linksInput.style.borderColor = '#00ff00'; });
                linksInput.addEventListener('dragleave', ()=>{ linksInput.style.borderColor = '#333'; });
                linksInput.addEventListener('drop', async (e)=>{
                    e.preventDefault(); linksInput.style.borderColor = '#333';
                    const text = (e.dataTransfer && e.dataTransfer.getData('text')) || '';
                    const urls = extractURLs(text).slice(0,5);
                    if (!urls.length) return;
                    
                    if (urls.length === 1) {
                        fetchStatus.innerHTML = '<div class="status processing">‚è≥ Downloading 1 video...</div>';
                        try {
                            const result = await fetchBatchUrls(urls);
                            const r = result.results && result.results[0];
                            if (result.success && r && r.success) {
                                saveHistoryEntry({ type: 'link', name: r.filename, url: r.download_url, size_mb: r.size_mb });
                                fetchStatus.innerHTML = `<div class="status completed">‚úì Downloaded <a href="${r.download_url}" class="download-link" download="${r.filename}">${r.filename}</a> <span style="color:#666;">(${r.size_mb}MB)</span> <button class="share-btn" data-url="${r.download_url}" data-filename="${r.filename}" style="margin-left:8px;">ü§ù Share</button></div>`;
                                if (autoDownloadEnabled) autoDownloadFile(r.download_url, r.filename);
                                renderHistory();
                            } else {
                                fetchStatus.innerHTML = `<div class=\"status failed\">‚úó Error: ${r && r.error ? r.error : 'Download failed'}</div>`;
                            }
                        } catch (err) {
                            fetchStatus.innerHTML = `<div class=\"status failed\">‚úó Error: ${err.message}</div>`;
                        }
                    } else {
                        linksInput.value = urls.join('\n');
                        fetchStatus.innerHTML = `<div class=\"status queued\">üìã ${urls.length} URLs dropped. Tap \"Download All Links\".</div>`;
                    }
                });
            }
        })();

        // Bulk link fetcher
        document.getElementById('fetchLinksBtn').addEventListener('click', async () => {
            const raw = (document.getElementById('linksInput').value || '').trim();
            if (!raw) {
                alert('Please paste at least one video URL');
                return;
            }
            
            const urls = raw.split('\n').map(s => s.trim()).filter(Boolean).slice(0, 5);
            const fetchStatus = document.getElementById('fetchStatus');
            
            fetchStatus.innerHTML = `<div class="status processing">‚è≥ Downloading ${urls.length} video${urls.length > 1 ? 's' : ''}...</div>`;
            document.getElementById('fetchLinksBtn').disabled = true;
            
            async function fetchBatch(targetUrls) {
                const response = await safeFetch('/api/videos/fetch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ urls: targetUrls })
                });
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`Server error (${response.status}): ${text}`);
                }
                return await response.json();
            }
            
            try {
                let result = await fetchBatch(urls);
                if (!result.success) throw new Error(result.error || 'Fetch failed');
                let finalResults = result.results;
                
                // Auto-retry for failures (once)
                const failed = finalResults.filter(r => !r.success).map(r => r.url);
                if (failed.length) {
                    try {
                        const retry = await fetchBatch(failed);
                        if (retry.success) {
                            // Merge: replace failures with retry successes
                            finalResults = finalResults.map(r => r.success ? r : (retry.results.find(rr => rr.url === r.url) || r));
                        }
                    } catch (e) {
                        // ignore retry errors
                    }
                }
                
                const items = finalResults.map(r => {
                    if (r.success) {
                        // Save to history
                        saveHistoryEntry({ type: 'link', name: r.filename, url: r.download_url, size_mb: r.size_mb });
                        return `<li style="margin-bottom:8px;">‚úì <a href="${r.download_url}" class="download-link" download="${r.filename}" style="color:#00ff00;">üì• ${r.filename}</a> <span style="color:#666;">(${r.size_mb}MB)</span> <button class="share-btn" data-url="${r.download_url}" data-filename="${r.filename}" style="margin-left:8px;">ü§ù Share</button></li>`;
                    }
                    return `<li style="margin-bottom:8px; color:#ff5555;">‚úó ${r.url.substring(0, 50)}... ‚Äî ${r.error}</li>`;
                }).join('');
                
                fetchStatus.innerHTML = `
                    <div class="status completed">
                        ‚úì Downloaded ${finalResults.filter(r=>r.success).length}/${finalResults.length} videos:<br>
                        <ul style="margin-top:10px; text-align:left; list-style:none; padding:0;">${items}</ul>
                        <p style="margin-top:12px; font-size:12px; color:#888;">üì± Tap each link to save to your phone</p>
                        <button id="copyAllLinksBtn" style="margin-top:10px; width:100%; background:#0066ff;">üìã Copy All Download Links</button>
                    </div>
                `;
                
                // Auto-download
                if (autoDownloadEnabled) {
                    finalResults.filter(r=>r.success).forEach(r => {
                        const a = document.createElement('a');
                        a.href = r.download_url;
                        a.download = r.filename;
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                    });
                }
                
                document.getElementById('linksInput').value = '';
                loadRecentJobs();
                renderHistory();
                
            } catch (err) {
                console.error('Fetch error:', err);
                // 4Ô∏è‚É£ PATCH: Queue downloads when offline
                if (err.message.includes('Failed to fetch')) {
                    // Queue all URLs for later processing
                    urls.forEach(url => queueDownload(url));
                    fetchStatus.innerHTML = `<div class="status failed">‚ö° Offline mode: ${urls.length} video${urls.length > 1 ? 's' : ''} queued for download when online.</div>`;
                } else {
                    fetchStatus.innerHTML = `<div class="status failed">‚úó Error: ${err.message}</div>`;
                }
            } finally {
                document.getElementById('fetchLinksBtn').disabled = false;
            }
        });
    </script>
</body>
</html>
