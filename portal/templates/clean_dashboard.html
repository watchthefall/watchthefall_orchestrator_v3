<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>WTF Brand Studio</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<style>
    * { box-sizing: border-box; }
    body {
        background: #000;
        color: #fff;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
        margin: 0;
        padding: 0 0 100px 0;
        -webkit-tap-highlight-color: transparent;
    }
    h1 {
        text-align: center;
        margin: 20px 0 15px;
        font-size: 28px;
        letter-spacing: 2px;
        text-shadow: 0 0 8px #00b7ff;
    }
    .glitch {
        position: relative;
        display: inline-block;
    }
    .section {
        width: 94%;
        max-width: 500px;
        margin: 15px auto;
        background: #111;
        padding: 18px;
        border-radius: 12px;
        box-shadow: 0 0 12px #00b7ff33;
    }
    h2 {
        margin: 0 0 12px;
        font-size: 18px;
        border-bottom: 1px solid #333;
        padding-bottom: 8px;
    }
    h3 {
        margin: 18px 0 10px;
        font-size: 15px;
        color: #00b7ff;
    }
    input[type="text"] {
        width: 100%;
        padding: 14px;
        margin: 8px 0;
        border-radius: 8px;
        border: none;
        font-size: 16px;
        background: #222;
        color: #fff;
    }
    button {
        width: 100%;
        padding: 14px;
        margin-top: 10px;
        border: none;
        background: #00b7ff;
        color: #000;
        border-radius: 8px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: background 0.2s;
    }
    button:hover, button:active {
        background: #0098d8;
    }
    button:disabled {
        background: #333;
        color: #666;
        cursor: not-allowed;
    }
    .brand-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        margin: 10px 0;
    }
    .brand-btn {
        padding: 12px 8px;
        background: #222;
        border: 2px solid #333;
        border-radius: 8px;
        color: #fff;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s;
        text-align: center;
    }
    .brand-btn.selected {
        background: #003355;
        border-color: #00b7ff;
        color: #00b7ff;
    }
    .brand-btn:active {
        transform: scale(0.98);
    }
    
    /* ========== PREVIEW CANVAS ========== */
    #previewSection {
        display: none;
    }
    .preview-container {
        position: relative;
        width: 100%;
        max-width: 360px;
        margin: 0 auto;
        background: #000;
        border: 2px dashed #333;
        border-radius: 8px;
        overflow: hidden;
    }
    #previewCanvas {
        display: block;
        width: 100%;
        height: auto;
        touch-action: none;
    }
    .watermark-bounds {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        border: 2px dashed rgba(0, 183, 255, 0.4);
        pointer-events: none;
        display: none;
    }
    .watermark-bounds.visible {
        display: block;
    }
    
    /* ========== SLIDERS ========== */
    .slider-group {
        margin: 15px 0;
    }
    .slider-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
    }
    .slider-label {
        font-size: 14px;
        color: #aaa;
    }
    .slider-value {
        font-weight: bold;
        color: #00b7ff;
        min-width: 50px;
        text-align: right;
    }
    input[type="range"] {
        -webkit-appearance: none;
        width: 100%;
        height: 8px;
        background: #333;
        border-radius: 4px;
        outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 24px;
        height: 24px;
        background: #00b7ff;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid #fff;
    }
    input[type="range"]::-moz-range-thumb {
        width: 24px;
        height: 24px;
        background: #00b7ff;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid #fff;
    }
    
    /* ========== TOGGLE SWITCHES ========== */
    .toggle-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 0;
        border-bottom: 1px solid #222;
    }
    .toggle-switch {
        position: relative;
        width: 50px;
        height: 28px;
    }
    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0; left: 0; right: 0; bottom: 0;
        background-color: #333;
        transition: 0.3s;
        border-radius: 28px;
    }
    .toggle-slider:before {
        position: absolute;
        content: "";
        height: 22px;
        width: 22px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.3s;
        border-radius: 50%;
    }
    input:checked + .toggle-slider {
        background-color: #00b7ff;
    }
    input:checked + .toggle-slider:before {
        transform: translateX(22px);
    }
    
    /* ========== RESULTS ========== */
    .download-link {
        display: block;
        padding: 14px;
        margin-top: 8px;
        background: #0099cc;
        color: white;
        text-align: center;
        border-radius: 8px;
        text-decoration: none;
        font-weight: bold;
    }
    .download-link:active {
        background: #007faa;
    }
    .status-msg {
        padding: 12px;
        margin: 10px 0;
        border-radius: 8px;
        font-size: 14px;
    }
    .status-msg.info { background: #1a3a4a; color: #7dd3fc; }
    .status-msg.success { background: #1a4a2e; color: #86efac; }
    .status-msg.error { background: #4a1a1a; color: #fca5a5; }
    
    /* ========== COLLAPSIBLE ========== */
    .collapsible-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        padding: 10px 0;
    }
    .collapsible-header h2 {
        margin: 0;
        border: none;
        padding: 0;
    }
    .collapse-icon {
        font-size: 20px;
        transition: transform 0.2s;
    }
    .collapsed .collapse-icon {
        transform: rotate(-90deg);
    }
    .collapsible-content {
        max-height: 1000px;
        overflow: hidden;
        transition: max-height 0.3s ease;
    }
    .collapsed .collapsible-content {
        max-height: 0;
    }
</style>
</head>
<body>

<h1><span class="glitch">WTF STUDIO</span></h1>

<!-- ========== SECTION 1: DOWNLOAD ========== -->
<div class="section">
    <h2>1. Get Video</h2>
    <input id="videoUrl" type="text" placeholder="Paste TikTok / Instagram / X link...">
    <button onclick="fetchVideo()" id="downloadBtn">‚¨á Download</button>
    <div id="downloadStatus"></div>
</div>

<!-- ========== SECTION 2: PREVIEW & CONFIGURE ========== -->
<div class="section" id="previewSection">
    <h2>2. Configure Branding</h2>
    
    <!-- Canvas Preview -->
    <div class="preview-container" id="previewContainer">
        <canvas id="previewCanvas" width="360" height="640"></canvas>
        <div class="watermark-bounds" id="watermarkBounds"></div>
    </div>
    
    <!-- Brand Selection -->
    <h3>Select Brands (Multi-select)</h3>
    <p style="color:#666; font-size:12px; margin:5px 0 10px;">üí° Click multiple brands - settings apply to all</p>
    <div class="brand-grid" id="brandsBox">Loading...</div>
    
    <!-- Watermark Controls -->
    <h3>üîç Watermark</h3>
    <div class="slider-group">
        <div class="slider-header">
            <span class="slider-label">Scale</span>
            <span class="slider-value" id="wmScaleVal">115%</span>
        </div>
        <input type="range" id="wmScale" min="100" max="200" value="115">
    </div>
    <div class="slider-group">
        <div class="slider-header">
            <span class="slider-label">Opacity</span>
            <span class="slider-value" id="wmOpacityVal">40%</span>
        </div>
        <input type="range" id="wmOpacity" min="10" max="80" value="40">
    </div>
    <div class="toggle-row">
        <span class="slider-label">Show Bounds</span>
        <label class="toggle-switch">
            <input type="checkbox" id="showBounds">
            <span class="toggle-slider"></span>
        </label>
    </div>
    
    <!-- Logo Controls -->
    <h3>üè∑Ô∏è Logo</h3>
    <div class="slider-group">
        <div class="slider-header">
            <span class="slider-label">Size</span>
            <span class="slider-value" id="logoScaleVal">15%</span>
        </div>
        <input type="range" id="logoScale" min="8" max="25" value="15">
    </div>
    <div class="slider-group">
        <div class="slider-header">
            <span class="slider-label">Padding</span>
            <span class="slider-value" id="logoPaddingVal">40px</span>
        </div>
        <input type="range" id="logoPadding" min="10" max="80" value="40">
    </div>
    <p style="color:#666; font-size:12px; margin:5px 0;">üí° Drag logo on preview to reposition</p>
    
    <!-- Text Layer Controls -->
    <h3>‚úçÔ∏è Text Layer</h3>
    <div class="toggle-row">
        <span class="slider-label">Enable Text</span>
        <label class="toggle-switch">
            <input type="checkbox" id="textEnabled" onchange="updateCanvasPreview()">
            <span class="toggle-slider"></span>
        </label>
    </div>
    <div id="textControls" style="display:none;">
        <div class="slider-group">
            <div class="slider-header">
                <span class="slider-label">Text Content</span>
            </div>
            <input type="text" id="textContent" placeholder="e.g., Follow for more..." oninput="updateCanvasPreview()">
        </div>
        <div class="slider-group">
            <div class="slider-header">
                <span class="slider-label">Position</span>
                <span class="slider-value" id="textPosVal">Bottom</span>
            </div>
            <select id="textPosition" onchange="document.getElementById('textPosVal').textContent = this.options[this.selectedIndex].text; updateCanvasPreview();" style="width:100%; padding:10px; background:#222; color:#fff; border:none; border-radius:8px;">
                <option value="top">Top</option>
                <option value="center">Center</option>
                <option value="bottom" selected>Bottom</option>
            </select>
        </div>
        <div class="slider-group">
            <div class="slider-header">
                <span class="slider-label">Font Size</span>
                <span class="slider-value" id="textSizeVal">48px</span>
            </div>
            <input type="range" id="textSize" min="24" max="96" value="48" oninput="document.getElementById('textSizeVal').textContent = this.value + 'px'; updateCanvasPreview();">
        </div>
        <div class="slider-group">
            <div class="slider-header">
                <span class="slider-label">Text Color</span>
                <span class="slider-value" id="textColorVal">#FFFFFF</span>
            </div>
            <input type="color" id="textColor" value="#FFFFFF" onchange="document.getElementById('textColorVal').textContent = this.value; updateCanvasPreview();" style="width:100%; height:40px; border:none; border-radius:8px; cursor:pointer;">
        </div>
        <div class="toggle-row">
            <span class="slider-label">Background Box</span>
            <label class="toggle-switch">
                <input type="checkbox" id="textBgEnabled" checked onchange="updateCanvasPreview()">
                <span class="toggle-slider"></span>
            </label>
        </div>
        <div class="slider-group">
            <div class="slider-header">
                <span class="slider-label">BG Opacity</span>
                <span class="slider-value" id="textBgOpacityVal">60%</span>
            </div>
            <input type="range" id="textBgOpacity" min="20" max="100" value="60" oninput="document.getElementById('textBgOpacityVal').textContent = this.value + '%'; updateCanvasPreview();">
        </div>
    </div>
    
    <!-- Save Config Button -->
    <button onclick="saveBrandConfig()" id="saveConfigBtn" style="background:#28a745; margin-top:15px;">üíæ Save Brand Config</button>
    <div id="saveResult" style="margin-top:5px;"></div>
    
    <!-- Process Button -->
    <button onclick="processBrands()" id="processBtn">‚ö° Apply Branding</button>
    <div id="processResult"></div>
</div>

<!-- ========== SECTION 3: DEBUG (Collapsed) ========== -->
<div class="section collapsed" id="debugSection">
    <div class="collapsible-header" onclick="toggleSection('debugSection')">
        <h2>Debug Tools</h2>
        <span class="collapse-icon">‚ñº</span>
    </div>
    <div class="collapsible-content">
        <button onclick="loadSystemStatus()">System Status</button>
        <div id="systemStatus" style="font-size:11px; margin-top:10px; color:#888;"></div>
        <button onclick="loadBrandIntegrity()" style="margin-top:10px;">Brand Integrity</button>
        <div id="brandIntegrity" style="font-size:11px; margin-top:10px; color:#888;"></div>
    </div>
</div>

<script>
const apiBase = window.location.origin;

// ========== STATE ==========
let currentFile = null;
let selectedBrands = [];  // Multi-brand support
let frameData = null;
let watermarkImg = null;
let logoImg = null;
let videoWidth = 720;
let videoHeight = 1280;

// Logo drag state
let logoDragging = false;
let logoX = 0;
let logoY = 0;
let logoDragStart = { x: 0, y: 0 };

// ========== CANVAS PREVIEW ==========
const canvas = document.getElementById('previewCanvas');
const ctx = canvas.getContext('2d');

function updateCanvasPreview() {
    if (!ctx) return;
    
    // Clear canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw frame (or placeholder)
    if (frameData) {
        const img = new Image();
        img.onload = () => {
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            drawOverlays();
        };
        img.src = frameData;
    } else {
        // Draw placeholder gradient
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#1a1a2e');
        gradient.addColorStop(1, '#16213e');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#333';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Download a video to preview', canvas.width/2, canvas.height/2);
        drawOverlays();
    }
}

function drawOverlays() {
    const wmScale = parseInt(document.getElementById('wmScale').value) / 100;
    const wmOpacity = parseInt(document.getElementById('wmOpacity').value) / 100;
    const logoScalePct = parseInt(document.getElementById('logoScale').value) / 100;
    const logoPad = parseInt(document.getElementById('logoPadding').value);
    
    // Draw watermark
    if (watermarkImg && watermarkImg.complete) {
        const scaledW = canvas.width * wmScale;
        const scaledH = canvas.height * wmScale;
        const offsetX = (scaledW - canvas.width) / 2;
        const offsetY = (scaledH - canvas.height) / 2;
        
        ctx.globalAlpha = wmOpacity;
        ctx.drawImage(watermarkImg, -offsetX, -offsetY, scaledW, scaledH);
        ctx.globalAlpha = 1.0;
    }
    
    // Draw logo
    if (logoImg && logoImg.complete) {
        const logoW = canvas.width * logoScalePct;
        const logoH = (logoImg.height / logoImg.width) * logoW;
        
        // Scale padding relative to canvas
        const scaledPad = (logoPad / 720) * canvas.width;
        
        // Default position: bottom-right
        if (logoX === 0 && logoY === 0) {
            logoX = canvas.width - logoW - scaledPad;
            logoY = canvas.height - logoH - scaledPad;
        }
        
        ctx.drawImage(logoImg, logoX, logoY, logoW, logoH);
        
        // Store logo bounds for hit testing
        canvas._logoBounds = { x: logoX, y: logoY, w: logoW, h: logoH };
    }
    
    // Draw text layer
    const textEnabled = document.getElementById('textEnabled').checked;
    const textContent = document.getElementById('textContent').value;
    
    // Show/hide text controls based on toggle
    document.getElementById('textControls').style.display = textEnabled ? 'block' : 'none';
    
    if (textEnabled && textContent) {
        const textPosition = document.getElementById('textPosition').value;
        const textSize = parseInt(document.getElementById('textSize').value);
        const textColor = document.getElementById('textColor').value;
        const textBgEnabled = document.getElementById('textBgEnabled').checked;
        const textBgOpacity = parseInt(document.getElementById('textBgOpacity').value) / 100;
        
        // Scale font size relative to canvas
        const scaledFontSize = Math.round(textSize * (canvas.width / 720));
        const margin = 40 * (canvas.width / 720);
        
        ctx.font = `bold ${scaledFontSize}px Arial`;
        ctx.textAlign = 'center';
        
        // Measure text
        const textMetrics = ctx.measureText(textContent);
        const textWidth = textMetrics.width;
        const textHeight = scaledFontSize;
        
        // Calculate Y position
        let textY;
        if (textPosition === 'top') {
            textY = margin + textHeight;
        } else if (textPosition === 'center') {
            textY = canvas.height / 2 + textHeight / 2;
        } else {  // bottom
            textY = canvas.height - margin;
        }
        
        const textX = canvas.width / 2;
        
        // Draw background box if enabled
        if (textBgEnabled) {
            const padding = 10 * (canvas.width / 720);
            ctx.fillStyle = `rgba(0, 0, 0, ${textBgOpacity})`;
            ctx.fillRect(
                textX - textWidth / 2 - padding,
                textY - textHeight - padding / 2,
                textWidth + padding * 2,
                textHeight + padding
            );
        }
        
        // Draw text
        ctx.fillStyle = textColor;
        ctx.fillText(textContent, textX, textY);
    }
    
    // Update watermark bounds outline
    const showBounds = document.getElementById('showBounds').checked;
    const boundsEl = document.getElementById('watermarkBounds');
    if (showBounds && watermarkImg) {
        const scaledW = canvas.width * wmScale;
        const scaledH = canvas.height * wmScale;
        const offsetX = (scaledW - canvas.width) / 2;
        const offsetY = (scaledH - canvas.height) / 2;
        
        // Calculate visible bounds within canvas
        const container = document.getElementById('previewContainer');
        const rect = container.getBoundingClientRect();
        const scaleRatio = rect.width / canvas.width;
        
        boundsEl.style.left = `${-offsetX * scaleRatio}px`;
        boundsEl.style.top = `${-offsetY * scaleRatio}px`;
        boundsEl.style.width = `${scaledW * scaleRatio}px`;
        boundsEl.style.height = `${scaledH * scaleRatio}px`;
        boundsEl.classList.add('visible');
    } else {
        boundsEl.classList.remove('visible');
    }
}

// ========== LOGO DRAG ==========
canvas.addEventListener('mousedown', startLogoDrag);
canvas.addEventListener('mousemove', dragLogo);
canvas.addEventListener('mouseup', endLogoDrag);
canvas.addEventListener('mouseleave', endLogoDrag);

// Touch support
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    startLogoDrag({ clientX: touch.clientX, clientY: touch.clientY });
}, { passive: false });
canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    dragLogo({ clientX: touch.clientX, clientY: touch.clientY });
}, { passive: false });
canvas.addEventListener('touchend', endLogoDrag);

function getCanvasCoords(e) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY
    };
}

function startLogoDrag(e) {
    if (!canvas._logoBounds) return;
    const pos = getCanvasCoords(e);
    const b = canvas._logoBounds;
    
    if (pos.x >= b.x && pos.x <= b.x + b.w && pos.y >= b.y && pos.y <= b.y + b.h) {
        logoDragging = true;
        logoDragStart = { x: pos.x - logoX, y: pos.y - logoY };
        canvas.style.cursor = 'grabbing';
    }
}

function dragLogo(e) {
    if (!logoDragging) return;
    const pos = getCanvasCoords(e);
    logoX = pos.x - logoDragStart.x;
    logoY = pos.y - logoDragStart.y;
    updateCanvasPreview();
}

function endLogoDrag() {
    logoDragging = false;
    canvas.style.cursor = 'default';
}

// ========== SLIDER LISTENERS ==========
document.getElementById('wmScale').addEventListener('input', (e) => {
    document.getElementById('wmScaleVal').textContent = e.target.value + '%';
    updateCanvasPreview();
});
document.getElementById('wmOpacity').addEventListener('input', (e) => {
    document.getElementById('wmOpacityVal').textContent = e.target.value + '%';
    updateCanvasPreview();
});
document.getElementById('logoScale').addEventListener('input', (e) => {
    document.getElementById('logoScaleVal').textContent = e.target.value + '%';
    // Reset logo position when scale changes
    logoX = 0; logoY = 0;
    updateCanvasPreview();
});
document.getElementById('logoPadding').addEventListener('input', (e) => {
    document.getElementById('logoPaddingVal').textContent = e.target.value + 'px';
    logoX = 0; logoY = 0;
    updateCanvasPreview();
});
document.getElementById('showBounds').addEventListener('change', updateCanvasPreview);

// ========== LOAD BRANDS ==========
async function loadBrands() {
    const box = document.getElementById('brandsBox');
    try {
        const res = await fetch(`${apiBase}/api/brands/list`);
        const data = await res.json();
        
        if (!data.success) {
            box.innerHTML = '<span style="color:#f66">Failed to load brands</span>';
            return;
        }
        
        box.innerHTML = '';
        data.brands.forEach(b => {
            const btn = document.createElement('div');
            btn.className = 'brand-btn';
            btn.textContent = b.display_name;
            btn.dataset.brand = b.name;
            btn.onclick = () => selectBrand(b.name, btn);
            box.appendChild(btn);
        });
    } catch (err) {
        box.innerHTML = '<span style="color:#f66">Error loading brands</span>';
    }
}

function selectBrand(brandName, btnEl) {
    // Toggle brand selection (multi-select)
    const idx = selectedBrands.indexOf(brandName);
    if (idx > -1) {
        selectedBrands.splice(idx, 1);  // Deselect
        btnEl.classList.remove('selected');
    } else {
        selectedBrands.push(brandName);  // Select
        btnEl.classList.add('selected');
    }
    
    // Load brand assets and saved config for preview (use first selected brand)
    if (selectedBrands.length > 0) {
        loadBrandAssets(selectedBrands[0]);
        loadBrandConfig(selectedBrands[0]);
    }
}

async function loadBrandConfig(brandName) {
    // Load saved config from database
    try {
        const res = await fetch(`${apiBase}/api/brands/${brandName}/config`);
        const data = await res.json();
        
        if (data.success && data.config) {
            const cfg = data.config;
            
            // Apply watermark settings
            document.getElementById('wmScale').value = Math.round(cfg.watermark_scale * 100);
            document.getElementById('wmScaleVal').textContent = Math.round(cfg.watermark_scale * 100) + '%';
            document.getElementById('wmOpacity').value = Math.round(cfg.watermark_opacity * 100);
            document.getElementById('wmOpacityVal').textContent = Math.round(cfg.watermark_opacity * 100) + '%';
            
            // Apply logo settings
            document.getElementById('logoScale').value = Math.round(cfg.logo_scale * 100);
            document.getElementById('logoScaleVal').textContent = Math.round(cfg.logo_scale * 100) + '%';
            document.getElementById('logoPadding').value = cfg.logo_padding;
            document.getElementById('logoPaddingVal').textContent = cfg.logo_padding + 'px';
            
            // Apply text layer settings
            document.getElementById('textEnabled').checked = !!cfg.text_enabled;
            document.getElementById('textContent').value = cfg.text_content || '';
            document.getElementById('textPosition').value = cfg.text_position || 'bottom';
            document.getElementById('textPosVal').textContent = (cfg.text_position || 'bottom').charAt(0).toUpperCase() + (cfg.text_position || 'bottom').slice(1);
            document.getElementById('textSize').value = cfg.text_size || 48;
            document.getElementById('textSizeVal').textContent = (cfg.text_size || 48) + 'px';
            document.getElementById('textColor').value = cfg.text_color || '#FFFFFF';
            document.getElementById('textColorVal').textContent = cfg.text_color || '#FFFFFF';
            document.getElementById('textBgEnabled').checked = cfg.text_bg_enabled !== false;
            document.getElementById('textBgOpacity').value = Math.round((cfg.text_bg_opacity || 0.6) * 100);
            document.getElementById('textBgOpacityVal').textContent = Math.round((cfg.text_bg_opacity || 0.6) * 100) + '%';
            
            // Show/hide text controls
            document.getElementById('textControls').style.display = cfg.text_enabled ? 'block' : 'none';
            
            console.log(`[UI] Loaded config for ${brandName}:`, cfg);
            updateCanvasPreview();
        }
    } catch (err) {
        console.error('Failed to load brand config:', err);
    }
}

async function saveBrandConfig() {
    if (selectedBrands.length === 0) {
        document.getElementById('saveResult').innerHTML = '<div class="status-msg error">Select a brand first</div>';
        return;
    }
    
    const brandName = selectedBrands[0];  // Save config for first selected brand
    const btn = document.getElementById('saveConfigBtn');
    const result = document.getElementById('saveResult');
    
    btn.disabled = true;
    btn.textContent = 'Saving...';
    
    const config = {
        watermark_scale: parseInt(document.getElementById('wmScale').value) / 100,
        watermark_opacity: parseInt(document.getElementById('wmOpacity').value) / 100,
        logo_scale: parseInt(document.getElementById('logoScale').value) / 100,
        logo_padding: parseInt(document.getElementById('logoPadding').value),
        text_enabled: document.getElementById('textEnabled').checked,
        text_content: document.getElementById('textContent').value,
        text_position: document.getElementById('textPosition').value,
        text_size: parseInt(document.getElementById('textSize').value),
        text_color: document.getElementById('textColor').value,
        text_bg_enabled: document.getElementById('textBgEnabled').checked,
        text_bg_opacity: parseInt(document.getElementById('textBgOpacity').value) / 100
    };
    
    try {
        const res = await fetch(`${apiBase}/api/brands/${brandName}/config`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(config)
        });
        
        const data = await res.json();
        
        if (data.success) {
            result.innerHTML = `<div class="status-msg success">‚úÖ Saved ${brandName}</div>`;
        } else {
            throw new Error(data.error || 'Save failed');
        }
    } catch (err) {
        result.innerHTML = `<div class="status-msg error">‚ùå ${err.message}</div>`;
    } finally {
        btn.disabled = false;
        btn.textContent = 'üíæ Save Brand Config';
    }
}

async function loadBrandAssets(brandName) {
    // Load watermark
    watermarkImg = new Image();
    watermarkImg.crossOrigin = 'anonymous';
    watermarkImg.onload = updateCanvasPreview;
    watermarkImg.src = `${apiBase}/api/preview/watermark/${brandName}`;
    
    // Load logo
    logoImg = new Image();
    logoImg.crossOrigin = 'anonymous';
    logoImg.onload = () => {
        logoX = 0; logoY = 0;  // Reset position
        updateCanvasPreview();
    };
    logoImg.src = `${apiBase}/api/preview/logo/${brandName}`;
}

// ========== DOWNLOAD VIDEO ==========
async function fetchVideo() {
    const url = document.getElementById('videoUrl').value.trim();
    const btn = document.getElementById('downloadBtn');
    const status = document.getElementById('downloadStatus');
    
    if (!url) {
        status.innerHTML = '<div class="status-msg error">Enter a URL</div>';
        return;
    }
    
    btn.disabled = true;
    btn.textContent = 'Downloading...';
    status.innerHTML = '<div class="status-msg info">‚è≥ Fetching video...</div>';
    
    try {
        const res = await fetch(`${apiBase}/api/videos/fetch`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ urls: [url] })
        });
        
        const data = await res.json();
        
        if (!data.success || !data.results[0]?.success) {
            throw new Error(data.results?.[0]?.error || 'Download failed');
        }
        
        currentFile = data.results[0].filename;
        localStorage.setItem('last_downloaded_file', currentFile);
        
        status.innerHTML = `<div class="status-msg success">‚úÖ Downloaded: ${currentFile}</div>`;
        
        // Show preview section
        document.getElementById('previewSection').style.display = 'block';
        
        // Extract frame for preview
        extractFrame(currentFile);
        
    } catch (err) {
        status.innerHTML = `<div class="status-msg error">‚ùå ${err.message}</div>`;
    } finally {
        btn.disabled = false;
        btn.textContent = '‚¨á Download';
    }
}

async function extractFrame(filename) {
    try {
        const res = await fetch(`${apiBase}/api/preview/extract-frame`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ filename })
        });
        
        const data = await res.json();
        
        if (data.success) {
            frameData = data.frame_data;
            videoWidth = data.width;
            videoHeight = data.height;
            
            // Adjust canvas aspect ratio
            canvas.height = canvas.width * (videoHeight / videoWidth);
            
            updateCanvasPreview();
        }
    } catch (err) {
        console.error('Frame extraction failed:', err);
    }
}

// ========== PROCESS BRANDING ==========
async function processBrands() {
    const btn = document.getElementById('processBtn');
    const result = document.getElementById('processResult');
    
    if (!currentFile) {
        result.innerHTML = '<div class="status-msg error">Download a video first</div>';
        return;
    }
    
    if (selectedBrands.length === 0) {
        result.innerHTML = '<div class="status-msg error">Select at least one brand</div>';
        return;
    }
    
    btn.disabled = true;
    btn.textContent = 'Processing...';
    result.innerHTML = '<div class="status-msg info">‚è≥ Applying branding (using saved configs)...</div>';
    
    try {
        // Backend uses saved config per brand - no need to send slider values
        const res = await fetch(`${apiBase}/api/videos/process_brands`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                source_path: currentFile,
                brands: selectedBrands  // Each brand uses its own saved config
            })
        });
        
        const data = await res.json();
        
        if (!data.success) {
            throw new Error(data.error || 'Processing failed');
        }
        
        // Show download links
        let html = '<div class="status-msg success">‚úÖ Done!</div>';
        data.outputs.forEach(o => {
            html += `<a class="download-link" href="${o.download_url}" download>‚¨á Download ${o.brand}</a>`;
        });
        result.innerHTML = html;
        
    } catch (err) {
        result.innerHTML = `<div class="status-msg error">‚ùå ${err.message}</div>`;
    } finally {
        btn.disabled = false;
        btn.textContent = '‚ö° Apply Branding';
    }
}

// ========== UTILITY ==========
function toggleSection(id) {
    document.getElementById(id).classList.toggle('collapsed');
}

async function loadSystemStatus() {
    const box = document.getElementById('systemStatus');
    box.textContent = 'Checking...';
    try {
        const res = await fetch(`${apiBase}/__debug_health`);
        const data = await res.json();
        box.textContent = JSON.stringify(data, null, 2);
    } catch (e) {
        box.textContent = 'Error: ' + e.message;
    }
}

async function loadBrandIntegrity() {
    const box = document.getElementById('brandIntegrity');
    box.textContent = 'Checking...';
    try {
        const res = await fetch(`${apiBase}/api/debug/brand-integrity`);
        const data = await res.json();
        box.textContent = JSON.stringify(data, null, 2);
    } catch (e) {
        box.textContent = 'Error: ' + e.message;
    }
}

// ========== INIT ==========
loadBrands();
updateCanvasPreview();

// Check for previously downloaded file
const lastFile = localStorage.getItem('last_downloaded_file');
if (lastFile) {
    currentFile = lastFile;
    document.getElementById('previewSection').style.display = 'block';
    extractFrame(lastFile);
}
</script>

</body>
</html>