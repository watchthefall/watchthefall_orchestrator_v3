<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>WTF Brand Studio</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<style>
    * { box-sizing: border-box; }
    body {
        background: #000;
        color: #fff;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
        margin: 0;
        padding: 0 0 100px 0;
        -webkit-tap-highlight-color: transparent;
    }
    h1 {
        text-align: center;
        margin: 20px 0 15px;
        font-size: 28px;
        letter-spacing: 2px;
        text-shadow: 0 0 8px #00b7ff;
    }
    .glitch {
        position: relative;
        display: inline-block;
    }
    .section {
        width: 94%;
        max-width: 500px;
        margin: 15px auto;
        background: #111;
        padding: 18px;
        border-radius: 12px;
        box-shadow: 0 0 12px #00b7ff33;
    }
    h2 {
        margin: 0 0 12px;
        font-size: 18px;
        border-bottom: 1px solid #333;
        padding-bottom: 8px;
    }
    h3 {
        margin: 18px 0 10px;
        font-size: 15px;
        color: #00b7ff;
    }
    input[type="text"] {
        width: 100%;
        padding: 14px;
        margin: 8px 0;
        border-radius: 8px;
        border: none;
        font-size: 16px;
        background: #222;
        color: #fff;
    }
    button {
        width: 100%;
        padding: 14px;
        margin-top: 10px;
        border: none;
        background: #00b7ff;
        color: #000;
        border-radius: 8px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: background 0.2s;
    }
    button:hover, button:active {
        background: #0098d8;
    }
    button:disabled {
        background: #333;
        color: #666;
        cursor: not-allowed;
    }
    .brand-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        margin: 10px 0;
    }
    .brand-btn {
        padding: 12px 8px;
        background: #222;
        border: 2px solid #333;
        border-radius: 8px;
        color: #fff;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s;
        text-align: center;
    }
    .brand-btn.selected {
        background: #003355;
        border-color: #00b7ff;
        color: #00b7ff;
    }
    .brand-btn:active {
        transform: scale(0.98);
    }
    
    /* ========== PREVIEW CANVAS ========== */
    #previewSection {
        display: none;
    }
    .preview-container {
        position: relative;
        width: 100%;
        max-width: 360px;
        margin: 0 auto;
        background: #000;
        border: 2px dashed #333;
        border-radius: 8px;
        overflow: hidden;
    }
    #previewCanvas {
        display: block;
        width: 100%;
        height: auto;
        touch-action: none;
    }
    .watermark-bounds {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        border: 2px dashed rgba(0, 183, 255, 0.4);
        pointer-events: none;
        display: none;
    }
    .watermark-bounds.visible {
        display: block;
    }
    
    /* ========== SLIDERS ========== */
    .slider-group {
        margin: 15px 0;
    }
    .slider-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
    }
    .slider-label {
        font-size: 14px;
        color: #aaa;
    }
    .slider-value {
        font-weight: bold;
        color: #00b7ff;
        min-width: 50px;
        text-align: right;
    }
    input[type="range"] {
        -webkit-appearance: none;
        width: 100%;
        height: 8px;
        background: #333;
        border-radius: 4px;
        outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 24px;
        height: 24px;
        background: #00b7ff;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid #fff;
    }
    input[type="range"]::-moz-range-thumb {
        width: 24px;
        height: 24px;
        background: #00b7ff;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid #fff;
    }
    
    /* ========== TOGGLE SWITCHES ========== */
    .toggle-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 0;
        border-bottom: 1px solid #222;
    }
    .toggle-switch {
        position: relative;
        width: 50px;
        height: 28px;
    }
    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0; left: 0; right: 0; bottom: 0;
        background-color: #333;
        transition: 0.3s;
        border-radius: 28px;
    }
    .toggle-slider:before {
        position: absolute;
        content: "";
        height: 22px;
        width: 22px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.3s;
        border-radius: 50%;
    }
    input:checked + .toggle-slider {
        background-color: #00b7ff;
    }
    input:checked + .toggle-slider:before {
        transform: translateX(22px);
    }
    
    /* ========== RESULTS ========== */
    .download-link {
        display: block;
        padding: 14px;
        margin-top: 8px;
        background: #0099cc;
        color: white;
        text-align: center;
        border-radius: 8px;
        text-decoration: none;
        font-weight: bold;
    }
    .download-link:active {
        background: #007faa;
    }
    .status-msg {
        padding: 12px;
        margin: 10px 0;
        border-radius: 8px;
        font-size: 14px;
    }
    .status-msg.info { background: #1a3a4a; color: #7dd3fc; }
    .status-msg.success { background: #1a4a2e; color: #86efac; }
    .status-msg.error { background: #4a1a1a; color: #fca5a5; }
    
    /* ========== COLLAPSIBLE ========== */
    .collapsible-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        padding: 10px 0;
    }
    .collapsible-header h2 {
        margin: 0;
        border: none;
        padding: 0;
    }
    .collapse-icon {
        font-size: 20px;
        transition: transform 0.2s;
    }
    .collapsed .collapse-icon {
        transform: rotate(-90deg);
    }
    .collapsible-content {
        max-height: 1000px;
        overflow: hidden;
        transition: max-height 0.3s ease;
    }
    .collapsed .collapsible-content {
        max-height: 0;
    }
</style>
</head>
<body>

<h1><span class="glitch">WTF STUDIO</span></h1>

<!-- ========== SECTION 1: DOWNLOAD ========== -->
<div class="section" id="downloadSection">
    <h2>1. Get Video</h2>
    <input id="videoUrl" type="text" placeholder="Paste TikTok / Instagram / X link...">
    <button onclick="fetchVideo()" id="downloadBtn">‚¨á Download</button>
    <div id="downloadStatus"></div>
</div>

<!-- ========== SECTION 2: PREVIEW & CONFIGURE ========== -->
<div class="section" id="previewSection">
    <h2>2. Configure Branding</h2>
    
    <!-- Canvas Preview -->
    <div class="preview-container" id="previewContainer">
        <canvas id="previewCanvas" width="360" height="640"></canvas>
        <div class="watermark-bounds" id="watermarkBounds"></div>
    </div>
    
    <!-- Queue Mode Header (hidden by default) -->
    <div id="queueModeHeader" style="display:none; margin-bottom:15px;">
        <div style="text-align:center; margin-bottom:10px;">
            <span style="font-size:14px; color:#888;">Brand Queue</span>
        </div>
        <!-- Clickable Brand Pills -->
        <div id="brandPillsContainer" style="display:flex; flex-wrap:wrap; gap:8px; justify-content:center; margin-bottom:15px;"></div>
        <!-- Status Summary -->
        <div id="queueStatusSummary" style="text-align:center; font-size:12px; color:#666; margin-bottom:10px;"></div>
    </div>
    
    <!-- Selection Mode Header (shown by default) -->
    <div id="selectionModeHeader">
        <h3>Select Brands (Multi-select)</h3>
        <p style="color:#666; font-size:12px; margin:5px 0 10px;">üí° Click multiple brands, then Start Branding</p>
    </div>
    <div class="brand-grid" id="brandsBox">Loading...</div>
    
    <!-- Override Controls (hidden in Selection Mode) -->
    <div id="overrideControls" style="display:none;">
    
    <!-- Watermark Controls -->
    <h3>üîç Watermark</h3>
    <div class="slider-group">
        <div class="slider-header">
            <span class="slider-label">Scale</span>
            <span class="slider-value" id="wmScaleVal">115%</span>
        </div>
        <input type="range" id="wmScale" min="100" max="200" value="115">
    </div>
    <div class="slider-group">
        <div class="slider-header">
            <span class="slider-label">Opacity</span>
            <span class="slider-value" id="wmOpacityVal">40%</span>
        </div>
        <input type="range" id="wmOpacity" min="10" max="80" value="40">
    </div>
    <div class="toggle-row">
        <span class="slider-label">Show Bounds</span>
        <label class="toggle-switch">
            <input type="checkbox" id="showBounds">
            <span class="toggle-slider"></span>
        </label>
    </div>
    
    <!-- Logo Controls -->
    <h3>üè∑Ô∏è Logo</h3>
    <div class="slider-group">
        <div class="slider-header">
            <span class="slider-label">Size</span>
            <span class="slider-value" id="logoScaleVal">15%</span>
        </div>
        <input type="range" id="logoScale" min="8" max="25" value="15">
    </div>
    <div class="slider-group">
        <div class="slider-header">
            <span class="slider-label">Padding</span>
            <span class="slider-value" id="logoPaddingVal">40px</span>
        </div>
        <input type="range" id="logoPadding" min="10" max="80" value="40">
    </div>
    <p style="color:#666; font-size:12px; margin:5px 0;">üí° Drag logo on preview to reposition</p>
    
    <!-- Text Layer Controls -->
    <h3>‚úçÔ∏è Text Layer</h3>
    <div class="toggle-row">
        <span class="slider-label">Enable Text</span>
        <label class="toggle-switch">
            <input type="checkbox" id="textEnabled" onchange="updateCanvasPreview()">
            <span class="toggle-slider"></span>
        </label>
    </div>
    <div id="textControls" style="display:none;">
        <div class="slider-group">
            <div class="slider-header">
                <span class="slider-label">Text Content</span>
            </div>
            <input type="text" id="textContent" placeholder="e.g., Follow for more..." oninput="updateCanvasPreview()">
        </div>
        <div class="slider-group">
            <div class="slider-header">
                <span class="slider-label">Position</span>
                <span class="slider-value" id="textPosVal">Bottom</span>
            </div>
            <select id="textPosition" onchange="document.getElementById('textPosVal').textContent = this.options[this.selectedIndex].text; updateCanvasPreview();" style="width:100%; padding:10px; background:#222; color:#fff; border:none; border-radius:8px;">
                <option value="top">Top</option>
                <option value="center">Center</option>
                <option value="bottom" selected>Bottom</option>
            </select>
        </div>
        <div class="slider-group">
            <div class="slider-header">
                <span class="slider-label">Font Size</span>
                <span class="slider-value" id="textSizeVal">48px</span>
            </div>
            <input type="range" id="textSize" min="24" max="96" value="48" oninput="document.getElementById('textSizeVal').textContent = this.value + 'px'; updateCanvasPreview();">
        </div>
        <div class="slider-group">
            <div class="slider-header">
                <span class="slider-label">Text Color</span>
                <span class="slider-value" id="textColorVal">#FFFFFF</span>
            </div>
            <input type="color" id="textColor" value="#FFFFFF" onchange="document.getElementById('textColorVal').textContent = this.value; updateCanvasPreview();" style="width:100%; height:40px; border:none; border-radius:8px; cursor:pointer;">
        </div>
        <div class="toggle-row">
            <span class="slider-label">Background Box</span>
            <label class="toggle-switch">
                <input type="checkbox" id="textBgEnabled" checked onchange="updateCanvasPreview()">
                <span class="toggle-slider"></span>
            </label>
        </div>
        <div class="slider-group">
            <div class="slider-header">
                <span class="slider-label">BG Opacity</span>
                <span class="slider-value" id="textBgOpacityVal">60%</span>
            </div>
            <input type="range" id="textBgOpacity" min="20" max="100" value="60" oninput="document.getElementById('textBgOpacityVal').textContent = this.value + '%'; updateCanvasPreview();">
        </div>
    </div>
    
    </div><!-- End overrideControls -->
    
    <!-- Selection Mode Button -->
    <div id="selectionModeActions">
        <button onclick="enterQueueMode()" id="startBrandingBtn" style="background:#00b7ff; margin-top:15px;">üöÄ Start Branding</button>
    </div>
    
    <!-- Queue Mode Actions (hidden by default) -->
    <div id="queueModeActions" style="display:none;">
        <button onclick="processCurrentBrand()" id="processCurrentBtn" style="background:#28a745;">‚ö° Process This Brand</button>
        <button onclick="processAllBrands()" id="processAllBtn" style="background:#00b7ff; margin-top:10px;">üöÄ Process All Remaining</button>
        <div style="display:flex; gap:10px; margin-top:10px;">
            <button onclick="skipBrand()" style="flex:1; background:#666;">Skip</button>
            <button onclick="exitQueueMode()" style="flex:1; background:#c00;">Exit Queue</button>
        </div>
    </div>
    
    <div id="processResult" style="margin-top:10px;"></div>
</div>

<!-- ========== SECTION 3: DEBUG (Collapsed) ========== -->
<div class="section collapsed" id="debugSection">
    <div class="collapsible-header" onclick="toggleSection('debugSection')">
        <h2>Debug Tools</h2>
        <span class="collapse-icon">‚ñº</span>
    </div>
    <div class="collapsible-content">
        <button onclick="loadSystemStatus()">System Status</button>
        <div id="systemStatus" style="font-size:11px; margin-top:10px; color:#888;"></div>
        <button onclick="loadBrandIntegrity()" style="margin-top:10px;">Brand Integrity</button>
        <div id="brandIntegrity" style="font-size:11px; margin-top:10px; color:#888;"></div>
    </div>
</div>

<script>
const apiBase = window.location.origin;

// ========== STATE ==========
let currentFile = null;
let selectedBrands = [];  // Multi-brand support
let frameData = null;
let watermarkImg = null;
let logoImg = null;
let videoWidth = 720;
let videoHeight = 1280;

// Logo drag state
let logoDragging = false;
let logoX = 0;
let logoY = 0;
let logoDragStart = { x: 0, y: 0 };

// ========== QUEUE MODE STATE ==========
let isQueueMode = false;
let processingQueue = [];
let currentQueueIndex = 0;

// ========== CANVAS PREVIEW ==========
const canvas = document.getElementById('previewCanvas');
const ctx = canvas.getContext('2d');

function updateCanvasPreview() {
    if (!ctx) return;
    
    // Clear canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw frame (or placeholder)
    if (frameData) {
        const img = new Image();
        img.onload = () => {
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            drawOverlays();
        };
        img.src = frameData;
    } else {
        // Draw placeholder gradient
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#1a1a2e');
        gradient.addColorStop(1, '#16213e');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#333';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Download a video to preview', canvas.width/2, canvas.height/2);
        drawOverlays();
    }
}

function drawOverlays() {
    const wmScale = parseInt(document.getElementById('wmScale').value) / 100;
    const wmOpacity = parseInt(document.getElementById('wmOpacity').value) / 100;
    const logoScalePct = parseInt(document.getElementById('logoScale').value) / 100;
    const logoPad = parseInt(document.getElementById('logoPadding').value);
    
    // Draw watermark
    if (watermarkImg && watermarkImg.complete) {
        const scaledW = canvas.width * wmScale;
        const scaledH = canvas.height * wmScale;
        const offsetX = (scaledW - canvas.width) / 2;
        const offsetY = (scaledH - canvas.height) / 2;
        
        ctx.globalAlpha = wmOpacity;
        ctx.drawImage(watermarkImg, -offsetX, -offsetY, scaledW, scaledH);
        ctx.globalAlpha = 1.0;
    }
    
    // Draw logo
    if (logoImg && logoImg.complete) {
        const logoW = canvas.width * logoScalePct;
        const logoH = (logoImg.height / logoImg.width) * logoW;
        
        // Scale padding relative to canvas
        const scaledPad = (logoPad / 720) * canvas.width;
        
        // Default position: bottom-right
        if (logoX === 0 && logoY === 0) {
            logoX = canvas.width - logoW - scaledPad;
            logoY = canvas.height - logoH - scaledPad;
        }
        
        ctx.drawImage(logoImg, logoX, logoY, logoW, logoH);
        
        // Store logo bounds for hit testing
        canvas._logoBounds = { x: logoX, y: logoY, w: logoW, h: logoH };
    }
    
    // Draw text layer
    const textEnabled = document.getElementById('textEnabled').checked;
    const textContent = document.getElementById('textContent').value;
    
    // Show/hide text controls based on toggle
    document.getElementById('textControls').style.display = textEnabled ? 'block' : 'none';
    
    if (textEnabled && textContent) {
        const textPosition = document.getElementById('textPosition').value;
        const textSize = parseInt(document.getElementById('textSize').value);
        const textColor = document.getElementById('textColor').value;
        const textBgEnabled = document.getElementById('textBgEnabled').checked;
        const textBgOpacity = parseInt(document.getElementById('textBgOpacity').value) / 100;
        
        // Scale font size relative to canvas
        const scaledFontSize = Math.round(textSize * (canvas.width / 720));
        const margin = 40 * (canvas.width / 720);
        
        ctx.font = `bold ${scaledFontSize}px Arial`;
        ctx.textAlign = 'center';
        
        // Measure text
        const textMetrics = ctx.measureText(textContent);
        const textWidth = textMetrics.width;
        const textHeight = scaledFontSize;
        
        // Calculate Y position
        let textY;
        if (textPosition === 'top') {
            textY = margin + textHeight;
        } else if (textPosition === 'center') {
            textY = canvas.height / 2 + textHeight / 2;
        } else {  // bottom
            textY = canvas.height - margin;
        }
        
        const textX = canvas.width / 2;
        
        // Draw background box if enabled
        if (textBgEnabled) {
            const padding = 10 * (canvas.width / 720);
            ctx.fillStyle = `rgba(0, 0, 0, ${textBgOpacity})`;
            ctx.fillRect(
                textX - textWidth / 2 - padding,
                textY - textHeight - padding / 2,
                textWidth + padding * 2,
                textHeight + padding
            );
        }
        
        // Draw text
        ctx.fillStyle = textColor;
        ctx.fillText(textContent, textX, textY);
    }
    
    // Update watermark bounds outline
    const showBounds = document.getElementById('showBounds').checked;
    const boundsEl = document.getElementById('watermarkBounds');
    if (showBounds && watermarkImg) {
        const scaledW = canvas.width * wmScale;
        const scaledH = canvas.height * wmScale;
        const offsetX = (scaledW - canvas.width) / 2;
        const offsetY = (scaledH - canvas.height) / 2;
        
        // Calculate visible bounds within canvas
        const container = document.getElementById('previewContainer');
        const rect = container.getBoundingClientRect();
        const scaleRatio = rect.width / canvas.width;
        
        boundsEl.style.left = `${-offsetX * scaleRatio}px`;
        boundsEl.style.top = `${-offsetY * scaleRatio}px`;
        boundsEl.style.width = `${scaledW * scaleRatio}px`;
        boundsEl.style.height = `${scaledH * scaleRatio}px`;
        boundsEl.classList.add('visible');
    } else {
        boundsEl.classList.remove('visible');
    }
}

// ========== LOGO DRAG ==========
canvas.addEventListener('mousedown', startLogoDrag);
canvas.addEventListener('mousemove', dragLogo);
canvas.addEventListener('mouseup', endLogoDrag);
canvas.addEventListener('mouseleave', endLogoDrag);

// Touch support
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    startLogoDrag({ clientX: touch.clientX, clientY: touch.clientY });
}, { passive: false });
canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    dragLogo({ clientX: touch.clientX, clientY: touch.clientY });
}, { passive: false });
canvas.addEventListener('touchend', endLogoDrag);

function getCanvasCoords(e) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY
    };
}

function startLogoDrag(e) {
    if (!canvas._logoBounds) return;
    const pos = getCanvasCoords(e);
    const b = canvas._logoBounds;
    
    if (pos.x >= b.x && pos.x <= b.x + b.w && pos.y >= b.y && pos.y <= b.y + b.h) {
        logoDragging = true;
        logoDragStart = { x: pos.x - logoX, y: pos.y - logoY };
        canvas.style.cursor = 'grabbing';
    }
}

function dragLogo(e) {
    if (!logoDragging) return;
    const pos = getCanvasCoords(e);
    logoX = pos.x - logoDragStart.x;
    logoY = pos.y - logoDragStart.y;
    updateCanvasPreview();
}

function endLogoDrag() {
    logoDragging = false;
    canvas.style.cursor = 'default';
}

// ========== SLIDER LISTENERS ==========
document.getElementById('wmScale').addEventListener('input', (e) => {
    document.getElementById('wmScaleVal').textContent = e.target.value + '%';
    updateCanvasPreview();
});
document.getElementById('wmOpacity').addEventListener('input', (e) => {
    document.getElementById('wmOpacityVal').textContent = e.target.value + '%';
    updateCanvasPreview();
});
document.getElementById('logoScale').addEventListener('input', (e) => {
    document.getElementById('logoScaleVal').textContent = e.target.value + '%';
    // Reset logo position when scale changes
    logoX = 0; logoY = 0;
    updateCanvasPreview();
});
document.getElementById('logoPadding').addEventListener('input', (e) => {
    document.getElementById('logoPaddingVal').textContent = e.target.value + 'px';
    logoX = 0; logoY = 0;
    updateCanvasPreview();
});
document.getElementById('showBounds').addEventListener('change', updateCanvasPreview);

// ========== LOAD BRANDS ==========
async function loadBrands() {
    const box = document.getElementById('brandsBox');
    try {
        const res = await fetch(`${apiBase}/api/brands/list`);
        const data = await res.json();
        
        if (!data.success) {
            box.innerHTML = '<span style="color:#f66">Failed to load brands</span>';
            return;
        }
        
        box.innerHTML = '';
        data.brands.forEach(b => {
            const btn = document.createElement('div');
            btn.className = 'brand-btn';
            btn.textContent = b.display_name;
            btn.dataset.brand = b.name;
            btn.onclick = () => selectBrand(b.name, btn);
            box.appendChild(btn);
        });
    } catch (err) {
        box.innerHTML = '<span style="color:#f66">Error loading brands</span>';
    }
}

function selectBrand(brandName, btnEl) {
    // Toggle brand selection (multi-select)
    const idx = selectedBrands.indexOf(brandName);
    if (idx > -1) {
        selectedBrands.splice(idx, 1);  // Deselect
        btnEl.classList.remove('selected');
    } else {
        selectedBrands.push(brandName);  // Select
        btnEl.classList.add('selected');
    }
    
    // Load brand assets and saved config for preview (use first selected brand)
    if (selectedBrands.length > 0) {
        loadBrandAssets(selectedBrands[0]);
        loadBrandConfig(selectedBrands[0]);
    }
}

async function loadBrandConfig(brandName) {
    // Load saved config from database
    try {
        const res = await fetch(`${apiBase}/api/brands/${brandName}/config`);
        const data = await res.json();
        
        if (data.success && data.config) {
            const cfg = data.config;
            
            // Apply watermark settings
            document.getElementById('wmScale').value = Math.round(cfg.watermark_scale * 100);
            document.getElementById('wmScaleVal').textContent = Math.round(cfg.watermark_scale * 100) + '%';
            document.getElementById('wmOpacity').value = Math.round(cfg.watermark_opacity * 100);
            document.getElementById('wmOpacityVal').textContent = Math.round(cfg.watermark_opacity * 100) + '%';
            
            // Apply logo settings
            document.getElementById('logoScale').value = Math.round(cfg.logo_scale * 100);
            document.getElementById('logoScaleVal').textContent = Math.round(cfg.logo_scale * 100) + '%';
            document.getElementById('logoPadding').value = cfg.logo_padding;
            document.getElementById('logoPaddingVal').textContent = cfg.logo_padding + 'px';
            
            // Apply text layer settings
            document.getElementById('textEnabled').checked = !!cfg.text_enabled;
            document.getElementById('textContent').value = cfg.text_content || '';
            document.getElementById('textPosition').value = cfg.text_position || 'bottom';
            document.getElementById('textPosVal').textContent = (cfg.text_position || 'bottom').charAt(0).toUpperCase() + (cfg.text_position || 'bottom').slice(1);
            document.getElementById('textSize').value = cfg.text_size || 48;
            document.getElementById('textSizeVal').textContent = (cfg.text_size || 48) + 'px';
            document.getElementById('textColor').value = cfg.text_color || '#FFFFFF';
            document.getElementById('textColorVal').textContent = cfg.text_color || '#FFFFFF';
            document.getElementById('textBgEnabled').checked = cfg.text_bg_enabled !== false;
            document.getElementById('textBgOpacity').value = Math.round((cfg.text_bg_opacity || 0.6) * 100);
            document.getElementById('textBgOpacityVal').textContent = Math.round((cfg.text_bg_opacity || 0.6) * 100) + '%';
            
            // Show/hide text controls
            document.getElementById('textControls').style.display = cfg.text_enabled ? 'block' : 'none';
            
            console.log(`[UI] Loaded config for ${brandName}:`, cfg);
            updateCanvasPreview();
        }
    } catch (err) {
        console.error('Failed to load brand config:', err);
    }
}

async function loadBrandAssets(brandName) {
    // Load watermark
    watermarkImg = new Image();
    watermarkImg.crossOrigin = 'anonymous';
    watermarkImg.onload = updateCanvasPreview;
    watermarkImg.src = `${apiBase}/api/preview/watermark/${brandName}`;
    
    // Load logo
    logoImg = new Image();
    logoImg.crossOrigin = 'anonymous';
    logoImg.onload = () => {
        logoX = 0; logoY = 0;  // Reset position
        updateCanvasPreview();
    };
    logoImg.src = `${apiBase}/api/preview/logo/${brandName}`;
}

// ========== QUEUE MODE FUNCTIONS ==========

function enterQueueMode() {
    const result = document.getElementById('processResult');
    
    if (!currentFile) {
        result.innerHTML = '<div class="status-msg error">Download a video first</div>';
        return;
    }
    
    if (selectedBrands.length === 0) {
        result.innerHTML = '<div class="status-msg error">Select at least one brand</div>';
        return;
    }
    
    // Initialize queue with selected brands (overrides loaded async)
    processingQueue = selectedBrands.map(brandName => ({
        brand_name: brandName,
        overrides: null,  // Will be loaded from DB
        status: 'pending'  // pending, editing, processing, done, failed, skipped
    }));
    currentQueueIndex = 0;
    isQueueMode = true;
    
    // Hide selection mode, show queue mode
    document.getElementById('downloadSection').style.display = 'none';  // Hide download section
    document.getElementById('selectionModeHeader').style.display = 'none';
    document.getElementById('brandsBox').style.display = 'none';
    document.getElementById('selectionModeActions').style.display = 'none';
    document.getElementById('queueModeHeader').style.display = 'block';
    document.getElementById('queueModeActions').style.display = 'block';
    document.getElementById('overrideControls').style.display = 'block';  // Show sliders now
    result.innerHTML = '';
    
    // Build brand pills
    renderBrandPills();
    
    // Load first brand
    switchToBrand(0);
}

function renderBrandPills() {
    const container = document.getElementById('brandPillsContainer');
    container.innerHTML = '';
    
    processingQueue.forEach((item, idx) => {
        const pill = document.createElement('button');
        pill.className = 'brand-pill';
        pill.dataset.index = idx;
        pill.onclick = () => switchToBrand(idx);
        
        // Status-based styling
        let statusIcon = '';
        let bgColor = '#333';
        
        if (item.status === 'done') {
            statusIcon = '\u2713 ';
            bgColor = '#28a745';
        } else if (item.status === 'processing') {
            statusIcon = '\u23F3 ';
            bgColor = '#f90';
        } else if (item.status === 'failed') {
            statusIcon = '\u274C ';
            bgColor = '#c00';
        } else if (item.status === 'skipped') {
            statusIcon = '\u2212 ';
            bgColor = '#666';
        } else if (idx === currentQueueIndex) {
            bgColor = '#00b7ff';  // Active/editing
        }
        
        pill.innerHTML = statusIcon + item.brand_name;
        pill.style.cssText = `
            padding: 8px 16px;
            border: none;
            border-radius: 20px;
            background: ${bgColor};
            color: #fff;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.2s;
        `;
        
        if (idx === currentQueueIndex) {
            pill.style.transform = 'scale(1.05)';
            pill.style.boxShadow = '0 0 10px rgba(0, 183, 255, 0.5)';
        }
        
        container.appendChild(pill);
    });
    
    updateQueueStatusSummary();
}

function updateQueueStatusSummary() {
    const summary = document.getElementById('queueStatusSummary');
    const done = processingQueue.filter(q => q.status === 'done').length;
    const processing = processingQueue.filter(q => q.status === 'processing').length;
    const pending = processingQueue.filter(q => q.status === 'pending' || q.status === 'editing').length;
    const failed = processingQueue.filter(q => q.status === 'failed').length;
    
    let parts = [];
    if (done > 0) parts.push(`${done} done`);
    if (processing > 0) parts.push(`${processing} processing`);
    if (pending > 0) parts.push(`${pending} pending`);
    if (failed > 0) parts.push(`${failed} failed`);
    
    summary.textContent = parts.join(' \u2022 ');
}

async function switchToBrand(idx) {
    // Save current brand's overrides before switching
    if (currentQueueIndex !== idx && processingQueue[currentQueueIndex]) {
        saveCurrentOverridesFromSliders();
    }
    
    currentQueueIndex = idx;
    const current = processingQueue[idx];
    
    // Skip if already processing/done
    if (current.status === 'processing') {
        document.getElementById('processResult').innerHTML = '<div class="status-msg info">This brand is currently processing...</div>';
        return;
    }
    
    // Update pills to show active state
    renderBrandPills();
    
    // Load brand assets for preview
    await loadBrandAssets(current.brand_name);
    
    // Load brand defaults from DB if not already loaded
    if (!current.overrides) {
        try {
            const res = await fetch(`${apiBase}/api/brands/${current.brand_name}/config`);
            const data = await res.json();
            
            if (data.success && data.config) {
                current.overrides = {
                    watermark_scale: data.config.watermark_scale || 1.15,
                    watermark_opacity: data.config.watermark_opacity || 0.4,
                    logo_scale: data.config.logo_scale || 0.15,
                    logo_padding: data.config.logo_padding || 40,
                    text_enabled: !!data.config.text_enabled,
                    text_content: data.config.text_content || '',
                    text_position: data.config.text_position || 'bottom',
                    text_size: data.config.text_size || 48,
                    text_color: data.config.text_color || '#FFFFFF',
                    text_bg_enabled: data.config.text_bg_enabled !== false,
                    text_bg_opacity: data.config.text_bg_opacity || 0.6
                };
            } else {
                current.overrides = getDefaultOverrides();
            }
        } catch (err) {
            console.error('Failed to load brand config:', err);
            current.overrides = getDefaultOverrides();
        }
    }
    
    // Mark as editing
    current.status = 'editing';
    
    // Load overrides into sliders
    loadOverridesIntoSliders(current.overrides);
    
    // Clear any previous result message
    document.getElementById('processResult').innerHTML = `<div class="status-msg info">Editing: ${current.brand_name}</div>`;
}

function getDefaultOverrides() {
    return {
        watermark_scale: 1.15,
        watermark_opacity: 0.4,
        logo_scale: 0.15,
        logo_padding: 40,
        text_enabled: false,
        text_content: '',
        text_position: 'bottom',
        text_size: 48,
        text_color: '#FFFFFF',
        text_bg_enabled: true,
        text_bg_opacity: 0.6
    };
}

function loadOverridesIntoSliders(overrides) {
    // Watermark
    document.getElementById('wmScale').value = Math.round(overrides.watermark_scale * 100);
    document.getElementById('wmScaleVal').textContent = Math.round(overrides.watermark_scale * 100) + '%';
    document.getElementById('wmOpacity').value = Math.round(overrides.watermark_opacity * 100);
    document.getElementById('wmOpacityVal').textContent = Math.round(overrides.watermark_opacity * 100) + '%';
    
    // Logo
    document.getElementById('logoScale').value = Math.round(overrides.logo_scale * 100);
    document.getElementById('logoScaleVal').textContent = Math.round(overrides.logo_scale * 100) + '%';
    document.getElementById('logoPadding').value = overrides.logo_padding;
    document.getElementById('logoPaddingVal').textContent = overrides.logo_padding + 'px';
    
    // Text layer
    document.getElementById('textEnabled').checked = overrides.text_enabled;
    document.getElementById('textContent').value = overrides.text_content;
    document.getElementById('textPosition').value = overrides.text_position;
    document.getElementById('textPosVal').textContent = overrides.text_position.charAt(0).toUpperCase() + overrides.text_position.slice(1);
    document.getElementById('textSize').value = overrides.text_size;
    document.getElementById('textSizeVal').textContent = overrides.text_size + 'px';
    document.getElementById('textColor').value = overrides.text_color;
    document.getElementById('textColorVal').textContent = overrides.text_color;
    document.getElementById('textBgEnabled').checked = overrides.text_bg_enabled;
    document.getElementById('textBgOpacity').value = Math.round(overrides.text_bg_opacity * 100);
    document.getElementById('textBgOpacityVal').textContent = Math.round(overrides.text_bg_opacity * 100) + '%';
    
    // Show/hide text controls
    document.getElementById('textControls').style.display = overrides.text_enabled ? 'block' : 'none';
    
    // Reset logo position and update preview
    logoX = 0; logoY = 0;
    updateCanvasPreview();
}

function saveCurrentOverridesFromSliders() {
    const current = processingQueue[currentQueueIndex];
    if (!current) return;
    
    current.overrides = {
        watermark_scale: parseInt(document.getElementById('wmScale').value) / 100,
        watermark_opacity: parseInt(document.getElementById('wmOpacity').value) / 100,
        logo_scale: parseInt(document.getElementById('logoScale').value) / 100,
        logo_padding: parseInt(document.getElementById('logoPadding').value),
        text_enabled: document.getElementById('textEnabled').checked,
        text_content: document.getElementById('textContent').value,
        text_position: document.getElementById('textPosition').value,
        text_size: parseInt(document.getElementById('textSize').value),
        text_color: document.getElementById('textColor').value,
        text_bg_enabled: document.getElementById('textBgEnabled').checked,
        text_bg_opacity: parseInt(document.getElementById('textBgOpacity').value) / 100
    };
}

async function confirmAndDownload() {
    // Legacy - redirect to processCurrentBrand
    await processCurrentBrand();
}

async function processCurrentBrand() {
    const current = processingQueue[currentQueueIndex];
    const btn = document.getElementById('processCurrentBtn');
    const result = document.getElementById('processResult');
    
    // Save current slider state to this brand's overrides
    saveCurrentOverridesFromSliders();
    
    // Mark as processing
    current.status = 'processing';
    renderBrandPills();
    
    result.innerHTML = `<div class="status-msg info">\u23F3 Processing ${current.brand_name}...</div>`;
    
    // Find next brand to switch to while processing
    const nextIdx = findNextPendingBrand();
    if (nextIdx !== -1 && nextIdx !== currentQueueIndex) {
        // Non-blocking: switch to next brand immediately
        setTimeout(() => switchToBrand(nextIdx), 100);
    }
    
    // Process in background
    try {
        const res = await fetch(`${apiBase}/api/videos/process_brands`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                source_path: currentFile,
                brands: [current.brand_name],
                watermark_scale: current.overrides.watermark_scale,
                watermark_opacity: current.overrides.watermark_opacity,
                logo_scale: current.overrides.logo_scale,
                logo_padding: current.overrides.logo_padding,
                text_enabled: current.overrides.text_enabled,
                text_content: current.overrides.text_content,
                text_position: current.overrides.text_position,
                text_size: current.overrides.text_size,
                text_color: current.overrides.text_color,
                text_bg_enabled: current.overrides.text_bg_enabled,
                text_bg_opacity: current.overrides.text_bg_opacity
            })
        });
        
        const data = await res.json();
        
        if (!data.success) {
            throw new Error(data.error || 'Processing failed');
        }
        
        // Mark as done
        current.status = 'done';
        renderBrandPills();
        
        // Trigger download
        if (data.outputs && data.outputs[0]) {
            const downloadUrl = data.outputs[0].download_url;
            const link = document.createElement('a');
            link.href = downloadUrl;
            link.download = '';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // Show success if this is still the current brand
        if (processingQueue[currentQueueIndex] === current) {
            result.innerHTML = `<div class="status-msg success">\u2705 ${current.brand_name} done!</div>`;
        }
        
        // Check if all done
        checkQueueComplete();
        
    } catch (err) {
        current.status = 'failed';
        renderBrandPills();
        
        if (processingQueue[currentQueueIndex] === current) {
            result.innerHTML = `<div class="status-msg error">\u274C ${current.brand_name}: ${err.message}</div>
                                <button onclick="retryBrand(${processingQueue.indexOf(current)})" style="margin-top:10px; background:#f90;">Retry</button>`;
        }
    }
}

async function processAllBrands() {
    const result = document.getElementById('processResult');
    
    // Save current overrides first
    saveCurrentOverridesFromSliders();
    
    // Find all pending/editing brands
    const pendingBrands = processingQueue.filter(q => q.status === 'pending' || q.status === 'editing' || q.status === 'failed');
    
    if (pendingBrands.length === 0) {
        result.innerHTML = '<div class="status-msg info">No pending brands to process</div>';
        return;
    }
    
    result.innerHTML = `<div class="status-msg info">\ud83d\ude80 Processing ${pendingBrands.length} brands...</div>`;
    
    // Process all in parallel (non-blocking)
    const promises = pendingBrands.map(async (item) => {
        item.status = 'processing';
        renderBrandPills();
        
        try {
            const res = await fetch(`${apiBase}/api/videos/process_brands`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    source_path: currentFile,
                    brands: [item.brand_name],
                    watermark_scale: item.overrides.watermark_scale,
                    watermark_opacity: item.overrides.watermark_opacity,
                    logo_scale: item.overrides.logo_scale,
                    logo_padding: item.overrides.logo_padding,
                    text_enabled: item.overrides.text_enabled,
                    text_content: item.overrides.text_content,
                    text_position: item.overrides.text_position,
                    text_size: item.overrides.text_size,
                    text_color: item.overrides.text_color,
                    text_bg_enabled: item.overrides.text_bg_enabled,
                    text_bg_opacity: item.overrides.text_bg_opacity
                })
            });
            
            const data = await res.json();
            
            if (!data.success) {
                throw new Error(data.error || 'Processing failed');
            }
            
            item.status = 'done';
            renderBrandPills();
            
            // Trigger download
            if (data.outputs && data.outputs[0]) {
                const downloadUrl = data.outputs[0].download_url;
                const link = document.createElement('a');
                link.href = downloadUrl;
                link.download = '';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
            
            return { brand: item.brand_name, success: true };
            
        } catch (err) {
            item.status = 'failed';
            renderBrandPills();
            return { brand: item.brand_name, success: false, error: err.message };
        }
    });
    
    // Wait for all to complete
    const results = await Promise.all(promises);
    
    const successful = results.filter(r => r.success).length;
    const failed = results.filter(r => !r.success).length;
    
    if (failed === 0) {
        result.innerHTML = `<div class="status-msg success">\u2705 All ${successful} brands processed!</div>`;
    } else {
        result.innerHTML = `<div class="status-msg warning">\u2705 ${successful} done, \u274C ${failed} failed</div>`;
    }
    
    checkQueueComplete();
}

function findNextPendingBrand() {
    // Find next brand that's pending or editing (not processing/done)
    for (let i = 0; i < processingQueue.length; i++) {
        if (processingQueue[i].status === 'pending' || processingQueue[i].status === 'editing') {
            return i;
        }
    }
    return -1;
}

function retryBrand(idx) {
    const item = processingQueue[idx];
    item.status = 'pending';
    renderBrandPills();
    switchToBrand(idx);
}

function checkQueueComplete() {
    const allDone = processingQueue.every(q => q.status === 'done' || q.status === 'skipped' || q.status === 'failed');
    if (allDone) {
        const result = document.getElementById('processResult');
        const done = processingQueue.filter(q => q.status === 'done').length;
        const failed = processingQueue.filter(q => q.status === 'failed').length;
        const skipped = processingQueue.filter(q => q.status === 'skipped').length;
        
        result.innerHTML = `<div class="status-msg success">\ud83c\udf89 Queue complete! ${done} done, ${skipped} skipped, ${failed} failed</div>`;
    }
}

function skipBrand() {
    const current = processingQueue[currentQueueIndex];
    current.status = 'skipped';
    renderBrandPills();
    
    // Find next pending brand
    const nextIdx = findNextPendingBrand();
    if (nextIdx !== -1) {
        switchToBrand(nextIdx);
    } else {
        checkQueueComplete();
    }
}

function advanceQueue() {
    // Legacy function - find next pending brand
    const nextIdx = findNextPendingBrand();
    if (nextIdx !== -1) {
        switchToBrand(nextIdx);
    } else {
        checkQueueComplete();
    }
}

function cancelQueue() {
    exitQueueMode();
}

function exitQueueMode() {
    isQueueMode = false;
    
    // Show selection mode, hide queue mode
    document.getElementById('downloadSection').style.display = 'block';  // Show download section
    document.getElementById('selectionModeHeader').style.display = 'block';
    document.getElementById('brandsBox').style.display = 'grid';
    document.getElementById('selectionModeActions').style.display = 'block';
    document.getElementById('queueModeHeader').style.display = 'none';
    document.getElementById('queueModeActions').style.display = 'none';
    document.getElementById('overrideControls').style.display = 'none';  // Hide sliders
    
    // Show completion summary
    const result = document.getElementById('processResult');
    const done = processingQueue.filter(q => q.status === 'done').length;
    const skipped = processingQueue.filter(q => q.status === 'skipped').length;
    const failed = processingQueue.filter(q => q.status === 'failed').length;
    
    if (processingQueue.length > 0) {
        result.innerHTML = `<div class="status-msg success">\u2705 Completed: ${done} done, ${skipped} skipped, ${failed} failed</div>`;
    } else {
        result.innerHTML = '';
    }
    
    // Reset queue
    processingQueue = [];
    currentQueueIndex = 0;
    
    // Clear brand selections
    selectedBrands = [];
    document.querySelectorAll('.brand-btn.selected').forEach(btn => {
        btn.classList.remove('selected');
    });
}

// ========== DOWNLOAD VIDEO ==========
async function fetchVideo() {
    const url = document.getElementById('videoUrl').value.trim();
    const btn = document.getElementById('downloadBtn');
    const status = document.getElementById('downloadStatus');
    
    if (!url) {
        status.innerHTML = '<div class="status-msg error">Enter a URL</div>';
        return;
    }
    
    btn.disabled = true;
    btn.textContent = 'Downloading...';
    status.innerHTML = '<div class="status-msg info">‚è≥ Fetching video...</div>';
    
    try {
        const res = await fetch(`${apiBase}/api/videos/fetch`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ urls: [url] })
        });
        
        const data = await res.json();
        
        if (!data.success || !data.results[0]?.success) {
            throw new Error(data.results?.[0]?.error || 'Download failed');
        }
        
        currentFile = data.results[0].filename;
        localStorage.setItem('last_downloaded_file', currentFile);
        
        status.innerHTML = `<div class="status-msg success">‚úÖ Downloaded: ${currentFile}</div>`;
        
        // Show preview section
        document.getElementById('previewSection').style.display = 'block';
        
        // Extract frame for preview
        extractFrame(currentFile);
        
    } catch (err) {
        status.innerHTML = `<div class="status-msg error">‚ùå ${err.message}</div>`;
    } finally {
        btn.disabled = false;
        btn.textContent = '‚¨á Download';
    }
}

async function extractFrame(filename) {
    try {
        const res = await fetch(`${apiBase}/api/preview/extract-frame`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ filename })
        });
        
        const data = await res.json();
        
        if (data.success) {
            frameData = data.frame_data;
            videoWidth = data.width;
            videoHeight = data.height;
            
            // Adjust canvas aspect ratio
            canvas.height = canvas.width * (videoHeight / videoWidth);
            
            updateCanvasPreview();
        }
    } catch (err) {
        console.error('Frame extraction failed:', err);
    }
}

// ========== UTILITY ==========
function toggleSection(id) {
    document.getElementById(id).classList.toggle('collapsed');
}

async function loadSystemStatus() {
    const box = document.getElementById('systemStatus');
    box.textContent = 'Checking...';
    try {
        const res = await fetch(`${apiBase}/__debug_health`);
        const data = await res.json();
        box.textContent = JSON.stringify(data, null, 2);
    } catch (e) {
        box.textContent = 'Error: ' + e.message;
    }
}

async function loadBrandIntegrity() {
    const box = document.getElementById('brandIntegrity');
    box.textContent = 'Checking...';
    try {
        const res = await fetch(`${apiBase}/api/debug/brand-integrity`);
        const data = await res.json();
        box.textContent = JSON.stringify(data, null, 2);
    } catch (e) {
        box.textContent = 'Error: ' + e.message;
    }
}

// ========== INIT ==========
loadBrands();
updateCanvasPreview();

// Check for previously downloaded file
const lastFile = localStorage.getItem('last_downloaded_file');
if (lastFile) {
    currentFile = lastFile;
    document.getElementById('previewSection').style.display = 'block';
    extractFrame(lastFile);
}
</script>

</body>
</html>